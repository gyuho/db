syntax = "proto3";

package raftpb;

import "github.com/gogo/protobuf/gogoproto/gogo.proto";

option (gogoproto.marshaler_all) = true;
option (gogoproto.sizer_all) = true;
option (gogoproto.unmarshaler_all) = true;
option (gogoproto.goproto_getters_all) = false;

import "raft/raftpb/entry.proto";
import "raft/raftpb/message_type.proto";
import "raft/raftpb/snapshot.proto";

// Message contains messages between nodes.
//
// (etcd raftpb.Message)
message Message {
	// Type defines the type of Message.
	MESSAGE_TYPE Type = 1;

	// From is the ID of the sender node.
	// (etcd: raft.raftpb.Message.From)
	uint64 From = 2;

	// To is the ID of the receiver node.
	// (etcd: raft.raftpb.Message.To)
	uint64 To   = 3;

	// SenderCurrentCommittedIndex is the index of highest log entry that is known to be
	// committed (initialized to 0, increasing monotonically). It is the
	// highest log position that is known to be in stable storage on a
	// quorum of nodes in the cluster.
	//
	//
	// Leader updates SenderCurrentCommittedIndex when sending out AppendEntries:
	//
	//   Leader.Message.SenderCurrentCommittedIndex = Leader.raftLog.committed
	//
	// (etcd: raft.*raft.sendAppend with raftpb.MsgApp)
	//
	//
	// Follower receives/reads Leader.SenderCurrentCommittedIndex in AppendEntries
	// and AppendEntries is only successful when:
	//
	//   i) Follower.raftLog.CommittedIndex > Leader.Message.LogIndex
	//   (etcd: raft.*raft.handleAppendEntries, raft.*Progress.maybeUpdate)
	//
	//   OR
	//
	//   ii) Follower.term(Leader.LogIndex) == Leader.Message.LogTerm
	//
	//   Conflicts:
	//
	//      Follower.term(Leader.Message.Entries[i].Index)
	//         != Leader.Message.Entries[i].Term
	//
	//   Then overwrite with Leader's log.
	//
	//   idx1 = Leader.Message.SenderCurrentCommittedIndex
	//   idx2 = Leader.Message.LogIndex + len(Leader.Message.Entries)
	//   Follower.raftLog.commitTo(min(idx1, idx2))
	//
	//   (etcd: raft.*raftLog.maybeAppend)
	//
	//
	// (etcd: raft.raftpb.Message.Commit)
	uint64 SenderCurrentCommittedIndex = 4;

	// SenderCurrentTerm is the latest term that the sender server has seen,
	// initialized to 0 on first boot, increasing monotonically.
	//
	// SenderCurrentTerm is 0 for local messages.
	//
	// SenderCurrentTerm gets updated whenever node sends out messages.
	//
	// If a node receives a message with higher SenderCurrentTerm,
	// it reverts back to Follower.
	// (etcd: raft.Step)
	//
	// If a node receives a message with lower SenderCurrentTerm,
	// it ignores that message.
	// (etcd: raft.Step)
	//
	// Candidate starts an election by increasing SenderCurrentTerm by 1.
	//
	// Follower overwrites its SenderCurrentTerm with leader's SenderCurrentTerm.
	//
	// (etcd: raft.raftpb.Message.Term)
	uint64 SenderCurrentTerm = 5;

	// LogIndex is the index of log entry immediately preceding the new ones.
	//
	//
	// Leader updates Leader.LogIndex when sending out:
	//
	//   i) RequestVote with:
	//
	//      Leader.Message.LogIndex = Leader.raftLog.lastIndex()
	//      Leader.Message.LogTerm  = Leader.raftLog.lastTerm()
	//
	//   so that Follower can reject or not.
	//   (etcd: raft.*raft.campaign with raftpb.MsgVote)
	//
	//   OR
	//
	//   ii) AppendEntries with:
	//
	//      Leader.Message.LogIndex = Leader.Follower.Progress.Next - 1
	//      Leader.Message.LogTerm  = Leader.raftLog.term(Leader.Follower.Progress.Next - 1)
	//
	//   to tell its Follower where those new entries start.
	//   (etcd: raft.*raft.sendAppend with raftpb.MsgApp)
	//
	//
	// Follower rejects RequestVote when:
	//
	//   i) Follower.raftLog.lastTerm() > Leader.Message.LogTerm
	//   (etcd: raft.stepFollower with raftpb.MsgVoteResp)
	//
	//   AND
	//
	//   ii) Follower.raftLog.lastIndex() > Leader.Message.LogIndex
	//   (etcd: raft.stepFollower with raftpb.MsgVoteResp)
	//
	//
	// Follower rejects AppendEntries when:
	//
	//   Follower.term(Leader.LogIndex) != Leader.Message.LogTerm
	//
	// (etcd: raft.*raft.handleAppendEntries, maybeAppend)
	//
	//
	// (etcd: raft.raftpb.Message.Index)
	uint64 LogIndex = 6;

	// LogTerm is the term of LogIndex, where new log entries start.
	//
	//
	// Leader updates Message.LogTerm when sending out:
	//
	//   AppendEntries with:
	//
	//      Leader.Message.LogIndex = Leader.Follower.Progress.Next - 1
	//      Leader.Message.LogTerm  = Leader.raftLog.term(Leader.Follower.Progress.Next - 1)
	//
	//   to tell followers where new log entries start.
	//   New log entries start from Leader.Follower.Progress.Next.
	//   (etcd: raft.*raft.sendAppend with raftpb.MsgApp)
	//
	//
	// Candidate updates Message.LogTerm when sending out:
	//
	//   RequestVote with:
	//
	//      Leader.Message.LogIndex = Follower.raftLog.lastIndex()
	//      Leader.Message.LogTerm  = Follower.raftLog.lastTerm()
	//
	//   (etcd: raft.*raft.campaign with raftpb.MsgVote)
	//
	//
	// Follower receives/reads Leader.Message.LogTerm:
	//
	//   1. When receiving RequestVote from Leader:
	//
	//   Follower only accepts the message when Leader's log is more up-to-date.
	//
	//      i)  Leader.Message.LogTerm > Follower.raftLog.lastTerm()
	//
	//      OR
	//
	//      ii) Leader.Message.LogIndex >= Follower.raftLog.lastIndex()
	//          AND
	//          Leader.Message.LogTerm  == Follower.raftLog.lastTerm()
	//
	//   (etcd: raft.*raftLog.isUpToDate with raftpb.MsgVoteResp)
	//
	//
	//   2. When Follower receives AppendEntries from Leader:
	//   AppendEntries is only successful when:
	//
	//      i)  Follower.raftLog.CommittedIndex > Leader.Message.LogIndex
	//
	//      to tell Follower is ahead of that message, so Follower ignores
	//      this Message, and Leader can update Leader.Follower.Progress.Next.
	//
	//      It will respond with:
	//         - To: Leader
	//         - Type: raftpb.MsgAppResp
	//         - LogIndex: Follower.raftLog.CommittedIndex
	//
	//      (etcd: raft.*raft.handleAppendEntries, raft.*Follower.Progress.maybeUpdate)
	//
	//      OR
	//
	//      ii) Follower.term(Leader.LogIndex) == Leader.Message.LogTerm
	//
	//      Otherwise, rejects AppendEntries RPC and responds to leader with:
	//         - To: Leader
	//         - Type: raftpb.MsgAppResp
	//         - LogIndex: Leader.Message.LogIndex
	//         - Reject: true
	//         - RejectHint: Follower.raftLog.lastIndex()
	//
	//      Conflicts:
	//
	//         Follower.term(Leader.Message.Entries[i].Index)
	//            != Leader.Message.Entries[i].Term
	//
	//      Then overwrite with Leader's log.
	//
	//      idx1 = Leader.Message.CommittedIndex
	//      idx2 = Leader.Message.LogIndex + len(Leader.Message.Entries)
	//      Follower.raftLog.commitTo(min(idx1, idx2))
	//
	//      (etcd: raft.*raft.handleAppendEntries, maybeAppend)
	//
	//
	// (etcd: raft.raftpb.Message.LogTerm)
	uint64 LogTerm = 7;

	// Entries is an array of Entry. They are stored in stable storage
	// before messages are sent.
	//
	// (etcd: raft.raftpb.Message.Entries)
	repeated Entry Entries = 8 [(gogoproto.nullable) = false]; // generate without pointer

	// Snapshot represents current in-memory state of the server.
	// It is stored in stable storage before messages are sent.
	//
	// To prevent logs from growing unbounded, Raft servers compact their
	// logs when the quorum of cluster is available. But when the unavailable
	// minority of servers become available, they need to catch up, by
	// receiving the snapshots from leader, because those missing log entries
	// are possibly gone forever (compacted). So servers sometimes sends snapshots
	// to each other across the network. Write-ahead log approach continuously
	// snapshots to the disk.
	//
	// When the leader decides to snapshot, it first logs a special start
	// entry. For slow followers, the leader will have to send an AppendEntries
	// RPC to the follower with an entry that the leader has already discarded
	// (compacted). In this case, the follower should just discard its entire
	// state. The leader will send the follower the log entries beginning with
	// the start entry.
	//
	// (etcd: raft.raftpb.Message.Snapshot)
	Snapshot Snapshot = 9 [(gogoproto.nullable) = false]; // generate without pointer

	// Reject is true when rejecting Message.
	// (etcd: raft.raftpb.Message.Reject, raftpb.MsgVoteResp)
	bool Reject = 10;

	// RejectHintFollowerLastIndex is used to tell Leader the correct last index of Follower.
	//
	// Follower sets:
	//
	//   Follower.Message.Type       = raftpb.MsgAppResp
	//   Follower.Message.LogIndex   = Leader.Message.LogIndex
	//   Follower.Message.Reject     = true
	//   Follower.Message.RejectHintFollowerLastIndex = Follower.raftLog.lastIndex()
	//
	//   (etcd: raft.*raft.handleAppendEntries)
	//
	// Then Leader receives this Mesasge with Message.Reject,
	// and decreases(updates):
	//
	//   idx1 = Follower.Message.LogIndex
	//   idx2 = Follower.Message.RejectHintFollowerLastIndex
	//   Leader.Follower.Progress.Next = min(idx1, idx2)
	//
	//   (etcd: raft.stepLeader with raftpb.MsgAppResp)
	//
	//
	// (etcd: raft.raftpb.Message.RejectHint, raftpb.MsgAppResp)
	uint64 RejectHintFollowerLastIndex = 11;
}
