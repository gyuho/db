syntax = "proto3";

package raftpb;

import "github.com/gogo/protobuf/gogoproto/gogo.proto";

option (gogoproto.marshaler_all) = true;
option (gogoproto.sizer_all) = true;
option (gogoproto.unmarshaler_all) = true;
option (gogoproto.goproto_getters_all) = false;

// (etcd raftpb.MessageType)
enum MESSAGE_TYPE {
	// INTERNAL_TRIGGER_FOLLOWER_OR_CANDIDATE_TO_START_CAMPAIGN message is used locally by Candidate/Follower
	// to start an election after election timeout.
	//
	// Every server in Raft starts as a follower, and when it has not received
	// any message from a valid leader before the randomized election timeout,
	// it will start an election to become a leader. To begin an election, a
	// follower increments its current term and becomes or remains Candidate.
	// Then votes for itself and send RequestVote RPCs in parallel to other peers.
	// (Raft 3.4 Leader election)
	//
	// It is an internal(local) message that is never sent to other peers over the network.
	//
	// (etcd: raft.raftpb.MsgHup)
	INTERNAL_TRIGGER_FOLLOWER_OR_CANDIDATE_TO_START_CAMPAIGN = 0;

	// INTERNAL_TRIGGER_LEADER_TO_SEND_HEARTBEAT message is used locally by Leader,
	// to signal the leader to send a LEADER_HEARTBEAT to its followers.
	// It is triggered periodically after heartbeat timeouts.
	//
	// It is an internal(local) message that is never sent to other peers over the network.
	//
	// (etcd: raft.raftpb.MsgBeat)
	INTERNAL_TRIGGER_LEADER_TO_SEND_HEARTBEAT = 1;

	// INTERNAL_TRIGGER_LEADER_TO_CHECK_QUORUM message is used locally by Leader,
	// to check if quorum of cluster (including itself) is active.
	// And if not, the leader steps down to a follower.
	//
	// Quorum is cluster size / 2 + 1.
	//
	// It is an internal(local) message that is never sent to other peers over the network.
	//
	// (etcd: raft.raftpb.MsgCheckQuorum)
	INTERNAL_TRIGGER_LEADER_TO_CHECK_QUORUM = 2;

	// LEADER_HEARTBEAT message is heartbeat from the Leader.
	// It is triggered by INTERNAL_TRIGGER_LEADER_TO_SEND_HEARTBEAT message, after every heartbeat
	// timeout, and is sent to leader's followers. It is same as an empty
	// raftpb.MsgApp, but includes raftpb.Message.Commit information for
	// followers.
	//
	//   idx1 = Leader.Follower.Progress.Match
	//   idx2 = Leader.raftLog.CommittedIndex
	//   Leader.LEADER_HEARTBEAT.SenderCurrentCommittedIndex = min(idx1, idx2)
	//
	// So that the followers can update their CommittedIndex.
	//
	// (etcd: raft.raftpb.MsgHeartbeat)
	LEADER_HEARTBEAT  = 3;

	// RESPONSE_TO_LEADER_HEARTBEAT message is the response from Follower,
	// for leader's LEADER_HEARTBEAT. It does not contain any information.
	// When a leader receives this message from a follower, the leader marks
	// this follower as active, and sends raftpb.MsgApp if needed.
	//
	// (etcd: raft.raftpb.MsgHeartbeatResp)
	RESPONSE_TO_LEADER_HEARTBEAT = 4;

	// CANDIDATE_REQUEST_VOTE message is sent by Candiate.
	// It is triggered by an election, and sent with the candidate's
	// information:
	//
	//   Candidate.CANDIDATE_REQUEST_VOTE.LogTerm  = Candidate.raftLog.lastTerm()
	//   Candidate.CANDIDATE_REQUEST_VOTE.LogIndex = Candidate.raftLog.lastIndex()
	//
	// (etcd: raft.raftpb.MsgVote)
	CANDIDATE_REQUEST_VOTE = 5;

	// RESPONSE_TO_CANDIDATE_REQUEST_VOTE message is the response to CANDIDATE_REQUEST_VOTE.
	//
	//
	// Leader receives CANDIDATE_REQUEST_VOTE from Candidate, and then:
	//
	//   Leader.RESPONSE_TO_CANDIDATE_REQUEST_VOTE.Reject = true
	//
	//
	// Candidate receives CANDIDATE_REQUEST_VOTE from another candidate, and then:
	//
	//   Candidate.RESPONSE_TO_CANDIDATE_REQUEST_VOTE.Reject = true
	//
	//
	// Follower receives CANDIDATE_REQUEST_VOTE from Candidate, and IF:
	//
	//   i) Candidate.Message.LogTerm > Follower.raftLog.lastTerm()
	//   OR
	//   ii) Candidate.Message.LogTerm == Follower.raftLog.lastTerm()
	//       AND
	//       Candidate.Message.LogIndex >= Follower.raftLog.lastIndex()
	//
	//   THEN
	//      Follower.RESPONSE_TO_CANDIDATE_REQUEST_VOTE.To     = Candidate
	//      Follower.RESPONSE_TO_CANDIDATE_REQUEST_VOTE.Reject = false
	//
	//   ELSE
	//      Follower.RESPONSE_TO_CANDIDATE_REQUEST_VOTE.To     = Candidate
	//      Follower.RESPONSE_TO_CANDIDATE_REQUEST_VOTE.Reject = true
	//
	// (etcd: raft.raftpb.MsgVoteResp)
	RESPONSE_TO_CANDIDATE_REQUEST_VOTE = 6;

	// PROPOSAL_TO_LEADER message is used to forward client requests to its leader,
	// because client requests in Raft are processed through the leader.
	// First option is for the server to reject the request and return the 
	// endpoint of the leader to the client. Or the server can proxy the client's
	// requests to the leader without rejection, so that clients can talk to any
	// node in the cluster.
	// (Raft 6.2 Routing requests to the leader)
	//
	// For Leader/Candidate, it is an internal(local) message that is never sent
	// to other peers over the network. For Follower, it is forwarded to Leader
	// over the network.
	//
	// It is triggered whenever local node.Propose, only contains:
	//
	//   Leader/Candidate/Follower.PROPOSAL_TO_LEADER.Entries = Entries
	//
	//
	// Leader receives Leader.PROPOSAL_TO_LEADER:
	//
	//   Leader.appendEntry(Leader.PROPOSAL_TO_LEADER.Entries)
	//   Leader.bcastAppend() to followers
	//
	//
	// Candidate receives Candidate.PROPOSAL_TO_LEADER:
	//
	//   Ignore Candidate.PROPOSAL_TO_LEADER
	//   because it means that there is no leader
	//
	//
	// Follower receives Follower.PROPOSAL_TO_LEADER:
	//
	//   i) Ignore Follower.PROPOSAL_TO_LEADER
	//      if there is no known leader
	//
	//   ii) Send Follower.PROPOSAL_TO_LEADER to its Leader
	//
	//       Follower.PROPOSAL_TO_LEADER.To = Leader
	//       Follower.PROPOSAL_TO_LEADER.Entries = Entries
	//
	//
	// (etcd: raft.raftpb.MsgProp)
	PROPOSAL_TO_LEADER = 7;

	// LEADER_REQUEST_APPEND message is only sent by Leader.
	//
	//   newLogIndex   = Leader.Follower.Progress.Next
	//   prevLogIndex  = newLogsIndex - 1
	//   prevLogTerm   = Leader.raftLog.term(prevLogIndex)
	//   entries       = Leader.raftLog.entries(newLogIndex, Leader.maxMsgSize)
	//   leaderCommit  = Leader.raftLog.CommittedIndex
	//
	//   Leader.LEADER_REQUEST_APPEND.SenderCurrentCommittedIndex = leaderCommit
	//   Leader.LEADER_REQUEST_APPEND.LogIndex                    = prevLogIndex
	//   Leader.LEADER_REQUEST_APPEND.LogTerm                     = prevLogTerm
	//   Leader.LEADER_REQUEST_APPEND.Entries                     = entries
	//
	// (etcd: raft.raftpb.MsgApp)
	LEADER_REQUEST_APPEND = 8;

	// RESPONSE_TO_LEADER_REQUEST_APPEND message is the response to Leader by Follower.
	//
	//   i) response to LEADER_REQUEST_APPEND:
	//
	//      IF
	//         Follower.raftLog.CommittedIndex > Leader.LEADER_REQUEST_APPEND.LogIndex
	//
	//      THEN
	//         Follower.RESPONSE_TO_LEADER_REQUEST_APPEND.To       = Leader
	//         Follower.RESPONSE_TO_LEADER_REQUEST_APPEND.LogIndex = Follower.raftLog.CommittedIndex
	//         Follower.RESPONSE_TO_LEADER_REQUEST_APPEND.Reject   = false
	//
	//      AND THEN
	//         Leader updates Leader.Follower.Progress
	//
	//      ELSE IF
	//         Leader.LEADER_REQUEST_APPEND.LogIndex >= Follower.raftLog.CommittedIndex
	//
	//      AND IF
	//         term1 = Leader.LEADER_REQUEST_APPEND.LogTerm
	//         term2 = Follower.term(Leader.LEADER_REQUEST_APPEND.LogIndex)
	//         term1 == term2
	//
	//         THEN
	//            idx1 = Leader.LEADER_REQUEST_APPEND.SenderCurrentCommittedIndex
	//            idx2 = Leader.LEADER_REQUEST_APPEND.LogIndex + len(new entries)
	//            Follower.raftLog.commitTo(min(idx1, idx2))
	//
	//            Follower.RESPONSE_TO_LEADER_REQUEST_APPEND.To       = Leader
	//            Follower.RESPONSE_TO_LEADER_REQUEST_APPEND.LogIndex = idx2
	//            Follower.RESPONSE_TO_LEADER_REQUEST_APPEND.Reject   = false
	//
	//      ELSE
	//         Follower.RESPONSE_TO_LEADER_REQUEST_APPEND.To         = Leader
	//         Follower.RESPONSE_TO_LEADER_REQUEST_APPEND.LogIndex   = Leader.LEADER_REQUEST_APPEND.LogIndex
	//         Follower.RESPONSE_TO_LEADER_REQUEST_APPEND.Reject     = true
	//         Follower.RESPONSE_TO_LEADER_REQUEST_APPEND.RejectHint = Follower.raftLog.lastIndex()
	//
	//         THEN
	//            Leader gets this Rejection and updates its Follower.Progress with:
	//               idx1 = Follower.RESPONSE_TO_LEADER_REQUEST_APPEND.LogIndex
	//               idx2 = Follower.RESPONSE_TO_LEADER_REQUEST_APPEND.RejectHint + 1
	//               Leader.Follower.Progress.Next = min(idx1, idx2)
	//
	//   (etcd: raft.*raft.handleAppendEntries)
	//
	//
	//   ii) response to LEADER_REQUEST_SNAPSHOT
	//
	//      IF
	//         idx1 = Follower.raftLog.CommittedIndex
	//         idx2 = Leader.LEADER_REQUEST_SNAPSHOT.Index
	//         idx1 >= idx2
	//            THEN false
	//
	//         idx   = Leader.LEADER_REQUEST_SNAPSHOT.Index
	//         term1 = Follower.raftLog.term(Leader.LEADER_REQUEST_SNAPSHOT.Index)
	//         term2 = Leader.LEADER_REQUEST_SNAPSHOT.Term
	//         term1 == term2
	//            THEN Follower.raftLog.commitTo(idx)
	//            AND THEN false
	//
	//      ELSE
	//         true
	//
	//      IF true, THEN successfully recovered the state machine from a snapshot
	//         Follower.RESPONSE_TO_LEADER_REQUEST_APPEND.To       = Leader
	//         Follower.RESPONSE_TO_LEADER_REQUEST_APPEND.LogIndex = Follower.raftLog.lastIndex()
	//         Follower.RESPONSE_TO_LEADER_REQUEST_APPEND.Reject   = false
	//
	//      ELSE ignores snapshot
	//         Follower.RESPONSE_TO_LEADER_REQUEST_APPEND.To       = Leader
	//         Follower.RESPONSE_TO_LEADER_REQUEST_APPEND.LogIndex = Follower.raftLog.CommittedIndex
	//         Follower.RESPONSE_TO_LEADER_REQUEST_APPEND.Reject   = false
	//
	//   (etcd: raft.*raft.handleSnapshot)
	//
	//
	//   iii)
	//      term1 = Follower.Term
	//      term2 = Leader.LEADER_HEARTBEAT.LogTerm
	//      term3 = Leader.LEADER_REQUEST_APPEND.LogTerm
	//      term1 > term2 || term1 > term3
	//
	//         THEN
	//            Follower received message from Leader with a lower term
	//         SO
	//            Follower ignores this message
	//
	//   (etcd: raft.*raft.Step)
	//
	//
	// (etcd: raft.raftpb.MsgAppResp)
	RESPONSE_TO_LEADER_REQUEST_APPEND = 9;

	// LEADER_REQUEST_SNAPSHOT is only sent by Leader.
	// It is triggered when the Leader tries to replicate its log (sendAppend) but:
	//
	//   i) term, err = Leader.raftLog.term(Leader.Follower.Progress.Next - 1)
	//      err == ErrCompacted
	//
	//   OR
	//
	//   ii) entries, err = Leader.raftLog.entries(Leader.Follower.Progress.Next, Leader.maxMsgSize)
	//       err != nil
	//
	//   THEN
	//      snap = Leader.raftLog.snapshot()
	//      Leader.LEADER_REQUEST_SNAPSHOT.Snapshot = snap
	//      Leader.Follower.Progress.becomeSnapshot(snap.Index)
	//
	//
	// (etcd: raft.raftpb.MsgSnap)
	LEADER_REQUEST_SNAPSHOT = 10;

	// INTERNAL_RESPONSE_TO_LEADER_REQUEST_SNAPSHOT message is the response to LEADER_REQUEST_SNAPSHOT from Follower.
	//
	// It is an internal(local) message that is never sent to other peers over the network.
	//
	// (etcd: raft.raftpb.MsgSnapStatus)
	INTERNAL_RESPONSE_TO_LEADER_REQUEST_SNAPSHOT = 11;

	// INTERNAL_UNREACHABLE_FOLLOWER message notifies Leader that Follower is not reachable.
	//
	// It is an internal(local) message that is never sent to other peers over the network.
	//
	// (etcd: raft.raftpb.MsgUnreachable)
	INTERNAL_UNREACHABLE_FOLLOWER = 12;

	// INTERNAL_LEADER_TRANSFER message allows Leader to transfer its leadership to another.
	//
	// It is an internal(local) message that is never sent to other peers over the network.
	//
	// (etcd: raft.raftpb.MsgTransferLeader)
	INTERNAL_LEADER_TRANSFER = 13;

	// FORCE_ELECTION_TIMEOUT message makes Leader send time-out message to its peers,
	// so that Follower can force election timeouts and start campaigning. Candidate
	// is already campaigning, so it ignores this message. It is used when the leader
	// transfer is happening.
	//
	// (etcd: raft.raftpb.MsgTimeoutNow)
	FORCE_ELECTION_TIMEOUT = 14;

	// READ_LEADER_CURRENT_COMMITTED_INDEX_REQUEST is used to serve clients' read-only queries without
	// going through Raft, but still with 'quorum-get' on. It bypasses the Raft log, but
	// still preserves the linearizability of reads, with lower costs.
	//
	// If a request goes through Raft log, it needs replication, which requires synchronous
	// disk writes in order to append those request entries to its log. Since read-only requests
	// do not change any state of replicated state machine, these writes can be time- and
	// resource-consuming.
	//
	// To bypass the Raft log with linearizable reads:
	//
	//   1. If Leader has not yet committed an entry from SenderCurrentTerm, it waits until it has done so.
	//
	//   2. Leader saves its SenderCurrentCommittedIndex in a local variable 'readIndex', which is used
	//      as a lower bound for the version of the state that read-only queries operate against.
	//
	//   3. Leader must ensure that it hasn't been superseded by a newer Leader,
	//      by issuing a new round of heartbeats and waiting for responses from cluster quorum.
	//
	//   4. These responses from Followers acknowledging the Leader indicates that
	//      there was no other Leader at the moment Leader sent out heartbeats.
	//
	//   5. Therefore, Leader's 'readIndex' was, at the time, the largest committed index,
	//      ever seen by any node in the cluster.
	//
	//   6. Leader now waits for its state machine to advance at least as far as the 'readIndex'.
	//      And this is current enought to satisfy linearizability.
	//
	//   7. Leader can now respond to those read-only client requests.
	//
	// (Raft 6.4 Processing read-only queries more efficiently, page 72)
	// (etcd: raft.raftpb.MsgReadIndex)
	READ_LEADER_CURRENT_COMMITTED_INDEX_REQUEST = 15;

	// RESPONSE_TO_READ_LEADER_CURRENT_COMMITTED_INDEX_REQUEST is response to READ_LEADER_CURRENT_COMMITTED_INDEX_REQUEST.
	//
	// (Raft 6.4 Processing read-only queries more efficiently, page 72)
	// (etcd: raft.raftpb.MsgReadIndexResp)
	RESPONSE_TO_READ_LEADER_CURRENT_COMMITTED_INDEX_REQUEST = 16;
}
