// Code generated by protoc-gen-gogo.
// source: raft/raftpb/message.proto
// DO NOT EDIT!

package raftpb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Message contains messages between nodes.
//
// (etcd raftpb.Message)
type Message struct {
	// Type defines the type of Message.
	Type MESSAGE_TYPE `protobuf:"varint,1,opt,name=Type,json=type,proto3,enum=raftpb.MESSAGE_TYPE" json:"Type,omitempty"`
	// From is the ID of the sender node.
	// (etcd: raft.raftpb.Message.From)
	From uint64 `protobuf:"varint,2,opt,name=From,json=from,proto3" json:"From,omitempty"`
	// To is the ID of the receiver node.
	// (etcd: raft.raftpb.Message.To)
	To uint64 `protobuf:"varint,3,opt,name=To,json=to,proto3" json:"To,omitempty"`
	// SenderCurrentCommittedIndex is the index of highest log entry that is known to be
	// committed (initialized to 0, increasing monotonically). It is the
	// highest log position that is known to be in stable storage on a
	// quorum of nodes in the cluster.
	//
	//
	// Leader updates SenderCurrentCommittedIndex when sending out AppendEntries:
	//
	//   Leader.Message.SenderCurrentCommittedIndex = Leader.raftLog.committed
	//
	// (etcd: raft.*raft.sendAppend with raftpb.MsgApp)
	//
	//
	// Follower receives/reads Leader.SenderCurrentCommittedIndex in AppendEntries
	// and AppendEntries is only successful when:
	//
	//   i) Follower.raftLog.CommittedIndex > Leader.Message.LogIndex
	//   (etcd: raft.*raft.handleAppendEntries, raft.*Progress.maybeUpdate)
	//
	//   OR
	//
	//   ii) Follower.term(Leader.LogIndex) == Leader.Message.LogTerm
	//
	//   Conflicts:
	//
	//      Follower.term(Leader.Message.Entries[i].Index)
	//         != Leader.Message.Entries[i].Term
	//
	//   Then overwrite with Leader's log.
	//
	//   idx1 = Leader.Message.SenderCurrentCommittedIndex
	//   idx2 = Leader.Message.LogIndex + len(Leader.Message.Entries)
	//   Follower.raftLog.commitTo(min(idx1, idx2))
	//
	//   (etcd: raft.*raftLog.maybeAppend)
	//
	//
	// (etcd: raft.raftpb.Message.Commit)
	SenderCurrentCommittedIndex uint64 `protobuf:"varint,4,opt,name=SenderCurrentCommittedIndex,json=senderCurrentCommittedIndex,proto3" json:"SenderCurrentCommittedIndex,omitempty"`
	// SenderCurrentTerm is the latest term that the sender server has seen,
	// initialized to 0 on first boot, increasing monotonically.
	//
	// SenderCurrentTerm is 0 for local messages.
	//
	// SenderCurrentTerm gets updated whenever node sends out messages.
	//
	// If a node receives a message with higher SenderCurrentTerm,
	// it reverts back to Follower.
	// (etcd: raft.Step)
	//
	// If a node receives a message with lower SenderCurrentTerm,
	// it ignores that message.
	// (etcd: raft.Step)
	//
	// Candidate starts an election by increasing SenderCurrentTerm by 1.
	//
	// Follower overwrites its SenderCurrentTerm with leader's SenderCurrentTerm.
	//
	// (etcd: raft.raftpb.Message.Term)
	SenderCurrentTerm uint64 `protobuf:"varint,5,opt,name=SenderCurrentTerm,json=senderCurrentTerm,proto3" json:"SenderCurrentTerm,omitempty"`
	// LogIndex is the index of log entry immediately preceding the new ones.
	//
	//
	// Leader updates Leader.LogIndex when sending out:
	//
	//   i) RequestVote with:
	//
	//      Leader.Message.LogIndex = Leader.raftLog.lastIndex()
	//      Leader.Message.LogTerm  = Leader.raftLog.lastTerm()
	//
	//   so that Follower can reject or not.
	//   (etcd: raft.*raft.campaign with raftpb.MsgVote)
	//
	//   OR
	//
	//   ii) AppendEntries with:
	//
	//      Leader.Message.LogIndex = Leader.Follower.Progress.Next - 1
	//      Leader.Message.LogTerm  = Leader.raftLog.term(Leader.Follower.Progress.Next - 1)
	//
	//   to tell its Follower where those new entries start.
	//   (etcd: raft.*raft.sendAppend with raftpb.MsgApp)
	//
	//
	// Follower rejects RequestVote when:
	//
	//   i) Follower.raftLog.lastTerm() > Leader.Message.LogTerm
	//   (etcd: raft.stepFollower with raftpb.MsgVoteResp)
	//
	//   AND
	//
	//   ii) Follower.raftLog.lastIndex() > Leader.Message.LogIndex
	//   (etcd: raft.stepFollower with raftpb.MsgVoteResp)
	//
	//
	// Follower rejects AppendEntries when:
	//
	//   Follower.term(Leader.LogIndex) != Leader.Message.LogTerm
	//
	// (etcd: raft.*raft.handleAppendEntries, maybeAppend)
	//
	//
	// (etcd: raft.raftpb.Message.Index)
	LogIndex uint64 `protobuf:"varint,6,opt,name=LogIndex,json=logIndex,proto3" json:"LogIndex,omitempty"`
	// LogTerm is the term of LogIndex, where new log entries start.
	//
	//
	// Leader updates Message.LogTerm when sending out:
	//
	//   AppendEntries with:
	//
	//      Leader.Message.LogIndex = Leader.Follower.Progress.Next - 1
	//      Leader.Message.LogTerm  = Leader.raftLog.term(Leader.Follower.Progress.Next - 1)
	//
	//   to tell followers where new log entries start.
	//   New log entries start from Leader.Follower.Progress.Next.
	//   (etcd: raft.*raft.sendAppend with raftpb.MsgApp)
	//
	//
	// Candidate updates Message.LogTerm when sending out:
	//
	//   RequestVote with:
	//
	//      Leader.Message.LogIndex = Follower.raftLog.lastIndex()
	//      Leader.Message.LogTerm  = Follower.raftLog.lastTerm()
	//
	//   (etcd: raft.*raft.campaign with raftpb.MsgVote)
	//
	//
	// Follower receives/reads Leader.Message.LogTerm:
	//
	//   1. When receiving RequestVote from Leader:
	//
	//   Follower only accepts the message when Leader's log is more up-to-date.
	//
	//      i)  Leader.Message.LogTerm > Follower.raftLog.lastTerm()
	//
	//      OR
	//
	//      ii) Leader.Message.LogIndex >= Follower.raftLog.lastIndex()
	//          AND
	//          Leader.Message.LogTerm  == Follower.raftLog.lastTerm()
	//
	//   (etcd: raft.*raftLog.isUpToDate with raftpb.MsgVoteResp)
	//
	//
	//   2. When Follower receives AppendEntries from Leader:
	//   AppendEntries is only successful when:
	//
	//      i)  Follower.raftLog.CommittedIndex > Leader.Message.LogIndex
	//
	//      to tell Follower is ahead of that message, so Follower ignores
	//      this Message, and Leader can update Leader.Follower.Progress.Next.
	//
	//      It will respond with:
	//         - To: Leader
	//         - Type: raftpb.MsgAppResp
	//         - LogIndex: Follower.raftLog.CommittedIndex
	//
	//      (etcd: raft.*raft.handleAppendEntries, raft.*Follower.Progress.maybeUpdate)
	//
	//      OR
	//
	//      ii) Follower.term(Leader.LogIndex) == Leader.Message.LogTerm
	//
	//      Otherwise, rejects AppendEntries RPC and responds to leader with:
	//         - To: Leader
	//         - Type: raftpb.MsgAppResp
	//         - LogIndex: Leader.Message.LogIndex
	//         - Reject: true
	//         - RejectHint: Follower.raftLog.lastIndex()
	//
	//      Conflicts:
	//
	//         Follower.term(Leader.Message.Entries[i].Index)
	//            != Leader.Message.Entries[i].Term
	//
	//      Then overwrite with Leader's log.
	//
	//      idx1 = Leader.Message.CommittedIndex
	//      idx2 = Leader.Message.LogIndex + len(Leader.Message.Entries)
	//      Follower.raftLog.commitTo(min(idx1, idx2))
	//
	//      (etcd: raft.*raft.handleAppendEntries, maybeAppend)
	//
	//
	// (etcd: raft.raftpb.Message.LogTerm)
	LogTerm uint64 `protobuf:"varint,7,opt,name=LogTerm,json=logTerm,proto3" json:"LogTerm,omitempty"`
	// Entries is an array of Entry. They are stored in stable storage
	// before messages are sent.
	//
	// (etcd: raft.raftpb.Message.Entries)
	Entries []Entry `protobuf:"bytes,8,rep,name=Entries,json=entries" json:"Entries"`
	// Snapshot represents current in-memory state of the server.
	// It is stored in stable storage before messages are sent.
	//
	// To prevent logs from growing unbounded, Raft servers compact their
	// logs when the quorum of cluster is available. But when the unavailable
	// minority of servers become available, they need to catch up, by
	// receiving the snapshots from leader, because those missing log entries
	// are possibly gone forever (compacted). So servers sometimes sends snapshots
	// to each other across the network. Write-ahead log approach continuously
	// snapshots to the disk.
	//
	// When the leader decides to snapshot, it first logs a special start
	// entry. For slow followers, the leader will have to send an AppendEntries
	// RPC to the follower with an entry that the leader has already discarded
	// (compacted). In this case, the follower should just discard its entire
	// state. The leader will send the follower the log entries beginning with
	// the start entry.
	//
	// (etcd: raft.raftpb.Message.Snapshot)
	Snapshot Snapshot `protobuf:"bytes,9,opt,name=Snapshot,json=snapshot" json:"Snapshot"`
	// Reject is true when rejecting Message.
	// (etcd: raft.raftpb.Message.Reject, raftpb.MsgVoteResp)
	Reject bool `protobuf:"varint,10,opt,name=Reject,json=reject,proto3" json:"Reject,omitempty"`
	// RejectHintFollowerLogLastIndex is used to tell Leader the correct last index of Follower.
	//
	// Follower sets:
	//
	//   Follower.Message.Type       = raftpb.MsgAppResp
	//   Follower.Message.LogIndex   = Leader.Message.LogIndex
	//   Follower.Message.Reject     = true
	//   Follower.Message.RejectHintFollowerLogLastIndex = Follower.raftLog.lastIndex()
	//
	//   (etcd: raft.*raft.handleAppendEntries)
	//
	// Then Leader receives this Mesasge with Message.Reject,
	// and decreases(updates):
	//
	//   idx1 = Follower.Message.LogIndex
	//   idx2 = Follower.Message.RejectHintFollowerLogLastIndex
	//   Leader.Follower.Progress.Next = min(idx1, idx2)
	//
	//   (etcd: raft.stepLeader with raftpb.MsgAppResp)
	//
	//
	// (etcd: raft.raftpb.Message.RejectHint, raftpb.MsgAppResp)
	RejectHintFollowerLogLastIndex uint64 `protobuf:"varint,11,opt,name=RejectHintFollowerLogLastIndex,json=rejectHintFollowerLogLastIndex,proto3" json:"RejectHintFollowerLogLastIndex,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptorMessage, []int{0} }

func init() {
	proto.RegisterType((*Message)(nil), "raftpb.Message")
}
func (m *Message) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Message) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintMessage(data, i, uint64(m.Type))
	}
	if m.From != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintMessage(data, i, uint64(m.From))
	}
	if m.To != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintMessage(data, i, uint64(m.To))
	}
	if m.SenderCurrentCommittedIndex != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintMessage(data, i, uint64(m.SenderCurrentCommittedIndex))
	}
	if m.SenderCurrentTerm != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintMessage(data, i, uint64(m.SenderCurrentTerm))
	}
	if m.LogIndex != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintMessage(data, i, uint64(m.LogIndex))
	}
	if m.LogTerm != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintMessage(data, i, uint64(m.LogTerm))
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			data[i] = 0x42
			i++
			i = encodeVarintMessage(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x4a
	i++
	i = encodeVarintMessage(data, i, uint64(m.Snapshot.Size()))
	n1, err := m.Snapshot.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.Reject {
		data[i] = 0x50
		i++
		if m.Reject {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.RejectHintFollowerLogLastIndex != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintMessage(data, i, uint64(m.RejectHintFollowerLogLastIndex))
	}
	return i, nil
}

func encodeFixed64Message(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Message(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintMessage(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Message) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMessage(uint64(m.Type))
	}
	if m.From != 0 {
		n += 1 + sovMessage(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovMessage(uint64(m.To))
	}
	if m.SenderCurrentCommittedIndex != 0 {
		n += 1 + sovMessage(uint64(m.SenderCurrentCommittedIndex))
	}
	if m.SenderCurrentTerm != 0 {
		n += 1 + sovMessage(uint64(m.SenderCurrentTerm))
	}
	if m.LogIndex != 0 {
		n += 1 + sovMessage(uint64(m.LogIndex))
	}
	if m.LogTerm != 0 {
		n += 1 + sovMessage(uint64(m.LogTerm))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovMessage(uint64(l))
		}
	}
	l = m.Snapshot.Size()
	n += 1 + l + sovMessage(uint64(l))
	if m.Reject {
		n += 2
	}
	if m.RejectHintFollowerLogLastIndex != 0 {
		n += 1 + sovMessage(uint64(m.RejectHintFollowerLogLastIndex))
	}
	return n
}

func sovMessage(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMessage(x uint64) (n int) {
	return sovMessage(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Message) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (MESSAGE_TYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.From |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.To |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderCurrentCommittedIndex", wireType)
			}
			m.SenderCurrentCommittedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SenderCurrentCommittedIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderCurrentTerm", wireType)
			}
			m.SenderCurrentTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SenderCurrentTerm |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogIndex", wireType)
			}
			m.LogIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LogIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogTerm", wireType)
			}
			m.LogTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LogTerm |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Snapshot.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reject", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reject = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RejectHintFollowerLogLastIndex", wireType)
			}
			m.RejectHintFollowerLogLastIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RejectHintFollowerLogLastIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessage(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthMessage
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMessage
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMessage(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMessage = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessage   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorMessage = []byte{
	// 404 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x7c, 0x51, 0xcf, 0x8e, 0x93, 0x40,
	0x18, 0xef, 0xb4, 0x08, 0x38, 0x8d, 0x1b, 0x77, 0xb2, 0xd1, 0x91, 0x4d, 0x46, 0xe2, 0x89, 0x83,
	0xdb, 0x26, 0xf8, 0x02, 0xba, 0x1b, 0xaa, 0x26, 0x6c, 0x62, 0x80, 0x8b, 0xa7, 0x0d, 0x6c, 0xa7,
	0x2c, 0x06, 0xf8, 0xc8, 0xcc, 0x34, 0xca, 0x9b, 0xf8, 0x38, 0x1e, 0x7b, 0xf4, 0x09, 0x8c, 0xd6,
	0x17, 0x31, 0x9d, 0x81, 0xa4, 0x1a, 0xf5, 0x42, 0xf8, 0xfd, 0xfd, 0xf8, 0x3e, 0xf0, 0x13, 0x91,
	0x6f, 0xd4, 0xf2, 0xf0, 0xe8, 0x8a, 0x65, 0xc3, 0xa5, 0xcc, 0x4b, 0xbe, 0xe8, 0x04, 0x28, 0x20,
	0xb6, 0x61, 0xbd, 0x8b, 0xb2, 0x52, 0x77, 0xdb, 0x62, 0x71, 0x0b, 0xcd, 0xb2, 0x84, 0x12, 0x96,
	0x5a, 0x2e, 0xb6, 0x1b, 0x8d, 0x34, 0xd0, 0x6f, 0x26, 0xe6, 0x3d, 0x3e, 0x6e, 0xe4, 0xad, 0x12,
	0xfd, 0x20, 0xb0, 0xbf, 0x8c, 0xba, 0x51, 0x7d, 0x37, 0xcc, 0xf3, 0xbc, 0x63, 0x5d, 0xb6, 0x79,
	0x27, 0xef, 0x40, 0x19, 0xed, 0xd9, 0x97, 0x19, 0x76, 0xae, 0x4d, 0x84, 0x04, 0xd8, 0xca, 0xfa,
	0x8e, 0x53, 0xe4, 0xa3, 0xe0, 0x24, 0x3c, 0x5b, 0x98, 0xc4, 0xe2, 0x3a, 0x4a, 0xd3, 0x57, 0xaf,
	0xa3, 0x9b, 0xec, 0xfd, 0xbb, 0x28, 0xb1, 0x0e, 0xbd, 0x84, 0x60, 0x6b, 0x25, 0xa0, 0xa1, 0x53,
	0x1f, 0x05, 0x56, 0x62, 0x6d, 0x04, 0x34, 0xe4, 0x04, 0x4f, 0x33, 0xa0, 0x33, 0xcd, 0x4c, 0x15,
	0x90, 0x97, 0xf8, 0x3c, 0xe5, 0xed, 0x9a, 0x8b, 0xab, 0xad, 0x10, 0xbc, 0x55, 0x57, 0xd0, 0x34,
	0x95, 0x52, 0x7c, 0xfd, 0xb6, 0x5d, 0xf3, 0x4f, 0xd4, 0xd2, 0xc6, 0x73, 0xf9, 0x6f, 0x0b, 0x79,
	0x8e, 0x4f, 0x7f, 0x6b, 0xc8, 0xb8, 0x68, 0xe8, 0x3d, 0x9d, 0x3b, 0x95, 0x7f, 0x0a, 0xc4, 0xc3,
	0x6e, 0x0c, 0xa5, 0x29, 0xb7, 0xb5, 0xc9, 0xad, 0x07, 0x4c, 0x28, 0x76, 0x62, 0x28, 0x75, 0xde,
	0xd1, 0x92, 0x53, 0x1b, 0x48, 0x2e, 0xb0, 0x13, 0xb5, 0x4a, 0x54, 0x5c, 0x52, 0xd7, 0x9f, 0x05,
	0xf3, 0xf0, 0xc1, 0xb8, 0xf6, 0x81, 0xee, 0x2f, 0xad, 0xdd, 0xb7, 0xa7, 0x93, 0xc4, 0xe1, 0xc6,
	0x43, 0x42, 0xec, 0xa6, 0xc3, 0x01, 0xe9, 0x7d, 0x1f, 0x05, 0xf3, 0xf0, 0xe1, 0xe8, 0x1f, 0xf9,
	0x21, 0xe2, 0x8e, 0x87, 0x26, 0x8f, 0xb0, 0x9d, 0xf0, 0x0f, 0xfc, 0x56, 0x51, 0xec, 0xa3, 0xc0,
	0x4d, 0x6c, 0xa1, 0x11, 0x59, 0x61, 0x66, 0xf8, 0x37, 0x55, 0xab, 0x56, 0x50, 0xd7, 0xf0, 0x91,
	0x8b, 0x18, 0xca, 0x38, 0x97, 0xca, 0xac, 0x31, 0xd7, 0xdf, 0xca, 0xc4, 0x7f, 0x5d, 0x97, 0x67,
	0xbb, 0x1f, 0x6c, 0xb2, 0xdb, 0x33, 0xf4, 0x75, 0xcf, 0xd0, 0xf7, 0x3d, 0x43, 0x9f, 0x7f, 0xb2,
	0x49, 0x61, 0xeb, 0xff, 0xfb, 0xe2, 0x57, 0x00, 0x00, 0x00, 0xff, 0xff, 0xc3, 0x65, 0x93, 0xf2,
	0x88, 0x02, 0x00, 0x00,
}
