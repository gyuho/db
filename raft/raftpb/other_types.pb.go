// Code generated by protoc-gen-gogo.
// source: raft/raftpb/other_types.proto
// DO NOT EDIT!

/*
	Package raftpb is a generated protocol buffer package.

	It is generated from these files:
		raft/raftpb/other_types.proto
		raft/raftpb/raftpb.proto

	It has these top-level messages:
		SoftState
		Entry
		ConfigState
		SnapshotMetadata
		Snapshot
		HardState
		ConfigChange
		Message
*/
package raftpb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// NODE_STATE represents the state of a node in a cluster.
type NODE_STATE int32

const (
	NODE_STATE_FOLLOWER  NODE_STATE = 0
	NODE_STATE_CANDIDATE NODE_STATE = 1
	NODE_STATE_LEADER    NODE_STATE = 2
)

var NODE_STATE_name = map[int32]string{
	0: "FOLLOWER",
	1: "CANDIDATE",
	2: "LEADER",
}
var NODE_STATE_value = map[string]int32{
	"FOLLOWER":  0,
	"CANDIDATE": 1,
	"LEADER":    2,
}

func (x NODE_STATE) String() string {
	return proto.EnumName(NODE_STATE_name, int32(x))
}
func (NODE_STATE) EnumDescriptor() ([]byte, []int) { return fileDescriptorOtherTypes, []int{0} }

// PROGRESS_STATE represents the state of Progress.
// Progress is leader's view of its followers' progress.
// Leader maintains progresses of all followers, and
// replicates entries to the followers based on their progresses.
// Progress has 'MatchIndex' and 'NextIndex'. 'MatchIndex' is the
// highest known matched index of follower entries. If unknown,
// it is set to 0. Then leader replicates entries from 'NextIndex'
// to its last one.
type PROGRESS_STATE int32

const (
	// When a follower is in PROBE state, leader sends at most one message
	// for each heartbeat interval. This is to probe the actual progress of
	// the follower.
	PROGRESS_STATE_PROBE PROGRESS_STATE = 0
	// When a follower is in REPLICATE state, leader replicates messages
	// by optimistically increasing 'NextIndex' to latest. This is an
	// optimized state for fast log replication. If it fails, leader sets
	// it back to PROBE.
	// The maximum number of entries per message and the maximum number of
	// inflight messages are configurable.
	PROGRESS_STATE_REPLICATE PROGRESS_STATE = 1
	// Leader changes follower's state from PROBE to SNAPSHOT
	// when the follower has fallen too far behind the leader,
	// and sends snapshot to the follower. Then leader must wait
	// until the success. After snapshot is applied, leader sets
	// it back to PROBE.
	PROGRESS_STATE_SNAPSHOT PROGRESS_STATE = 2
)

var PROGRESS_STATE_name = map[int32]string{
	0: "PROBE",
	1: "REPLICATE",
	2: "SNAPSHOT",
}
var PROGRESS_STATE_value = map[string]int32{
	"PROBE":     0,
	"REPLICATE": 1,
	"SNAPSHOT":  2,
}

func (x PROGRESS_STATE) String() string {
	return proto.EnumName(PROGRESS_STATE_name, int32(x))
}
func (PROGRESS_STATE) EnumDescriptor() ([]byte, []int) { return fileDescriptorOtherTypes, []int{1} }

// SNAPSHOT_STATUS represents the state of snapshot.
type SNAPSHOT_STATUS int32

const (
	SNAPSHOT_STATUS_FINISHED SNAPSHOT_STATUS = 0
	SNAPSHOT_STATUS_FAILED   SNAPSHOT_STATUS = 1
)

var SNAPSHOT_STATUS_name = map[int32]string{
	0: "FINISHED",
	1: "FAILED",
}
var SNAPSHOT_STATUS_value = map[string]int32{
	"FINISHED": 0,
	"FAILED":   1,
}

func (x SNAPSHOT_STATUS) String() string {
	return proto.EnumName(SNAPSHOT_STATUS_name, int32(x))
}
func (SNAPSHOT_STATUS) EnumDescriptor() ([]byte, []int) { return fileDescriptorOtherTypes, []int{2} }

// SoftState provides state that is useful for logging and debugging.
// The state is volatile and does not need to be persisted to the WAL.
//
// (etcd raftpb.SoftState)
type SoftState struct {
	NodeState NODE_STATE `protobuf:"varint,1,opt,name=NodeState,json=nodeState,proto3,enum=raftpb.NODE_STATE" json:"NodeState,omitempty"`
	LeaderID  uint64     `protobuf:"varint,2,opt,name=LeaderID,json=leaderID,proto3" json:"LeaderID,omitempty"`
}

func (m *SoftState) Reset()                    { *m = SoftState{} }
func (m *SoftState) String() string            { return proto.CompactTextString(m) }
func (*SoftState) ProtoMessage()               {}
func (*SoftState) Descriptor() ([]byte, []int) { return fileDescriptorOtherTypes, []int{0} }

func init() {
	proto.RegisterType((*SoftState)(nil), "raftpb.SoftState")
	proto.RegisterEnum("raftpb.NODE_STATE", NODE_STATE_name, NODE_STATE_value)
	proto.RegisterEnum("raftpb.PROGRESS_STATE", PROGRESS_STATE_name, PROGRESS_STATE_value)
	proto.RegisterEnum("raftpb.SNAPSHOT_STATUS", SNAPSHOT_STATUS_name, SNAPSHOT_STATUS_value)
}
func (m *SoftState) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SoftState) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NodeState != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintOtherTypes(data, i, uint64(m.NodeState))
	}
	if m.LeaderID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintOtherTypes(data, i, uint64(m.LeaderID))
	}
	return i, nil
}

func encodeFixed64OtherTypes(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32OtherTypes(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintOtherTypes(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *SoftState) Size() (n int) {
	var l int
	_ = l
	if m.NodeState != 0 {
		n += 1 + sovOtherTypes(uint64(m.NodeState))
	}
	if m.LeaderID != 0 {
		n += 1 + sovOtherTypes(uint64(m.LeaderID))
	}
	return n
}

func sovOtherTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozOtherTypes(x uint64) (n int) {
	return sovOtherTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SoftState) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowOtherTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SoftState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SoftState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeState", wireType)
			}
			m.NodeState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtherTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NodeState |= (NODE_STATE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderID", wireType)
			}
			m.LeaderID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowOtherTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LeaderID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipOtherTypes(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthOtherTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipOtherTypes(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowOtherTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOtherTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowOtherTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthOtherTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowOtherTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipOtherTypes(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthOtherTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowOtherTypes   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorOtherTypes = []byte{
	// 303 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x44, 0x90, 0xd1, 0x4a, 0xc3, 0x30,
	0x14, 0x86, 0x9b, 0xa1, 0xa3, 0x3d, 0xcc, 0x59, 0x82, 0x17, 0x63, 0x60, 0x19, 0x5e, 0x8d, 0x89,
	0xad, 0x28, 0x82, 0xb7, 0xdd, 0x92, 0xb9, 0x42, 0x68, 0x4a, 0x52, 0x11, 0xaf, 0xc6, 0xea, 0xb2,
	0x4d, 0x50, 0x33, 0x6a, 0x76, 0xe1, 0x9b, 0xf8, 0x48, 0xbb, 0xf4, 0x11, 0x74, 0xbe, 0x88, 0x2c,
	0xdd, 0xf0, 0x26, 0xe4, 0xe3, 0x3f, 0xdf, 0xf9, 0xe1, 0xc0, 0x69, 0x39, 0x99, 0x99, 0x68, 0xfb,
	0x2c, 0x8b, 0x48, 0x9b, 0x85, 0x2a, 0xc7, 0xe6, 0x63, 0xa9, 0xde, 0xc3, 0x65, 0xa9, 0x8d, 0xc6,
	0xf5, 0x2a, 0x69, 0x5f, 0xcc, 0x9f, 0xcd, 0x62, 0x55, 0x84, 0x4f, 0xfa, 0x35, 0x9a, 0xeb, 0xb9,
	0x8e, 0x6c, 0x5c, 0xac, 0x66, 0x96, 0x2c, 0xd8, 0x5f, 0xa5, 0x9d, 0x3d, 0x82, 0x27, 0xf5, 0xcc,
	0x48, 0x33, 0x31, 0x0a, 0x5f, 0x82, 0x97, 0xea, 0xa9, 0xb2, 0xd0, 0x42, 0x1d, 0xd4, 0x6d, 0x5e,
	0xe1, 0xb0, 0xda, 0x1b, 0xa6, 0x9c, 0xd0, 0xb1, 0xcc, 0xe3, 0x9c, 0x0a, 0xef, 0x6d, 0x3f, 0x84,
	0xdb, 0xe0, 0x32, 0x35, 0x99, 0xaa, 0x32, 0x21, 0xad, 0x5a, 0x07, 0x75, 0x0f, 0x84, 0xfb, 0xb2,
	0xe3, 0xde, 0x0d, 0xc0, 0xbf, 0x84, 0x1b, 0xe0, 0x0e, 0x39, 0x63, 0xfc, 0x81, 0x0a, 0xdf, 0xc1,
	0x47, 0xe0, 0x0d, 0xe2, 0x94, 0x24, 0x24, 0xce, 0xa9, 0x8f, 0x30, 0x40, 0x9d, 0xd1, 0x98, 0x50,
	0xe1, 0xd7, 0x7a, 0xb7, 0xd0, 0xcc, 0x04, 0xbf, 0x13, 0x54, 0xca, 0x9d, 0xea, 0xc1, 0x61, 0x26,
	0x78, 0x9f, 0x56, 0x9e, 0xa0, 0x19, 0x4b, 0x06, 0x95, 0xd7, 0x00, 0x57, 0xa6, 0x71, 0x26, 0x47,
	0x3c, 0xf7, 0x6b, 0xbd, 0x73, 0x38, 0xde, 0x93, 0x35, 0xef, 0xa5, 0x6d, 0x4d, 0xd2, 0x44, 0x8e,
	0x28, 0xf1, 0x9d, 0x6d, 0xcd, 0x30, 0x4e, 0x18, 0x25, 0x3e, 0xea, 0x9f, 0xac, 0x7f, 0x02, 0x67,
	0xbd, 0x09, 0xd0, 0xd7, 0x26, 0x40, 0xdf, 0x9b, 0x00, 0x7d, 0xfe, 0x06, 0x4e, 0x51, 0xb7, 0x57,
	0xb9, 0xfe, 0x0b, 0x00, 0x00, 0xff, 0xff, 0xb3, 0xb8, 0xd1, 0x42, 0x6d, 0x01, 0x00, 0x00,
}
