syntax = "proto3";

package raftpb;

import "github.com/gogo/protobuf/gogoproto/gogo.proto";

option (gogoproto.marshaler_all) = true;
option (gogoproto.sizer_all) = true;
option (gogoproto.unmarshaler_all) = true;
option (gogoproto.goproto_getters_all) = false;

enum ENTRY_TYPE {
	NORMAL        = 0;
	CONFIG_CHANGE = 1;
}

message Entry {
	ENTRY_TYPE Type = 1;

	uint64 Index = 2;
	uint64 Term  = 3;

	bytes Data = 4;
}

message ConfigState {
	repeated uint64 IDs = 1;
}

message SnapshotMetadata {
	ConfigState ConfigState = 1 [(gogoproto.nullable) = false]; // generate without pointer

	uint64 Index = 2;
	uint64 Term  = 3;
}

// Snapshot contains snapshot data and meta-data.
// It is stored in stable storage before messages are sent.
message Snapshot {
	SnapshotMetadata Metadata = 1 [(gogoproto.nullable) = false]; // generate without pointer
	bytes Data = 2;
}

// HardState is the current state of the Raft node.
// It is stored in stable storage before messages are sent.
message HardState {
	uint64 VotedFor    = 1;
	uint64 CommittedIndex = 2;
	uint64 Term        = 3;
}

enum CONFIG_CHANGE_TYPE {
	ADD_NODE    = 0;
	REMOVE_NODE = 1;
	UPDATE_NODE = 2;
}

message ConfigChange {
	CONFIG_CHANGE_TYPE Type = 1;

	uint64 ID     = 2;
	uint64 NodeID = 3;

	bytes Data = 4;
}

enum MESSAGE_TYPE {
	// INTERNAL_CAMPAIGN_START message is used locally by Candidate/Follower
	// to start an election after election timeout.
	//
	// Every server in Raft starts as a follower, and when it has not received
	// any message from a valid leader before the randomized election timeout,
	// it will start an election to become a leader. To begin an election, a
	// follower increments its current term and becomes or remains Candidate.
	// Then votes for itself and send RequestVote RPCs in parallel to other peers.
	// (Raft 3.4 Leader election)
	//
	// It is an internal(local) message that is never sent to other peers over the network.
	//
	// (etcd: raft.raftpb.MsgHup)
	INTERNAL_CAMPAIGN_START = 0;

	// INTERNAL_LEADER_SEND_HEARTBEAT message is used locally by Leader,
	// to signal the leader to send a LEADER_HEARTBEAT_REQUEST to its followers.
	// It is triggered periodically after heartbeat timeouts.
	//
	// It is an internal(local) message that is never sent to other peers over the network.
	//
	// (etcd: raft.raftpb.MsgBeat)
	INTERNAL_LEADER_SEND_HEARTBEAT = 1;

	// INTERNAL_CHECK_QUORUM message is used locally by Leader,
	// to check if quorum of cluster (including itself) is active.
	// And if not, the leader steps down to a follower.
	//
	// Quorum is cluster size / 2 + 1.
	//
	// It is an internal(local) message that is never sent to other peers over the network.
	//
	// (etcd: raft.raftpb.MsgCheckQuorum)
	INTERNAL_CHECK_QUORUM = 2;

	// LEADER_HEARTBEAT_REQUEST message is heartbeat from the Leader.
	// It is triggered by INTERNAL_LEADER_SEND_HEARTBEAT message, after every heartbeat
	// timeout, and is sent to leader's followers. It is same as an empty
	// raftpb.MsgApp, but includes raftpb.Message.Commit information for
	// followers.
	//
	//   idx1 = Leader.Follower.Progress.Match
	//   idx2 = Leader.raftLog.CommittedIndex
	//   Leader.LEADER_HEARTBEAT_REQUEST.CurrentCommittedIndex = min(idx1, idx2)
	//
	// So that the followers can update their CommittedIndex.
	//
	// (etcd: raft.raftpb.MsgHeartbeat)
	LEADER_HEARTBEAT_REQUEST  = 3;

	// HEARTBEAT_RESPONSE message is the response from Follower,
	// for leader's LEADER_HEARTBEAT_REQUEST. It does not contain any information.
	// When a leader receives this message from a follower, the leader marks
	// this follower as active, and sends raftpb.MsgApp if needed.
	//
	// (etcd: raft.raftpb.MsgHeartbeatResp)
	HEARTBEAT_RESPONSE = 4;

	// CANDIDATE_VOTE_REQUEST message is sent by Candiate.
	// It is triggered by an election, and sent with the candidate's
	// information:
	//
	//   Candidate.CANDIDATE_VOTE_REQUEST.LogTerm  = Candidate.raftLog.lastTerm()
	//   Candidate.CANDIDATE_VOTE_REQUEST.LogIndex = Candidate.raftLog.lastIndex()
	//
	// (etcd: raft.raftpb.MsgVote)
	CANDIDATE_VOTE_REQUEST = 5;

	// VOTE_RESPONSE message is the response to CANDIDATE_VOTE_REQUEST.
	//
	//
	// Leader receives CANDIDATE_VOTE_REQUEST from Candidate, and then:
	//
	//   Leader.VOTE_RESPONSE.Reject = true
	//
	//
	// Candidate receives CANDIDATE_VOTE_REQUEST from another candidate, and then:
	//
	//   Candidate.VOTE_RESPONSE.Reject = true
	//
	//
	// Follower receives CANDIDATE_VOTE_REQUEST from Candidate, and IF:
	//
	//   i) Candidate.Message.LogTerm > Follower.raftLog.lastTerm()
	//   OR
	//   ii) Candidate.Message.LogTerm == Follower.raftLog.lastTerm()
	//       AND
	//       Candidate.Message.LogIndex >= Follower.raftLog.lastIndex()
	//
	//   THEN
	//      Follower.VOTE_RESPONSE.To     = Candidate
	//      Follower.VOTE_RESPONSE.Reject = false
	//
	//   ELSE
	//      Follower.VOTE_RESPONSE.To     = Candidate
	//      Follower.VOTE_RESPONSE.Reject = true
	//
	// (etcd: raft.raftpb.MsgVoteResp)
	VOTE_RESPONSE = 6;

	// PROPOSAL message is used to forward client requests to its
	// leader, because client requests in Raft are processed through the
	// leader. First option is for the server to reject the request and
	// return the endpoint of the leader to the client. Or the server can proxy
	// the client's requests to the leader without rejection, so that clients
	// can talk to any node in the cluster.
	// (Raft 6.2 Routing requests to the leader)
	//
	// For Leader/Candidate, it is an internal(local) message that is never
	// sent to other peers over the network. For Follower, it is forwarded
	// to Leader over the network.
	//
	// It is triggered whenever local node.Propose, only contains:
	//
	//   Leader/Candidate/Follower.PROPOSAL.Entries = Entries
	//
	//
	// Leader receives Leader.PROPOSAL:
	//
	//   Leader.appendEntry(Leader.PROPOSAL.Entries)
	//   Leader.bcastAppend() to followers
	//
	//
	// Candidate receives Candidate.PROPOSAL:
	//
	//   Ignore Candidate.PROPOSAL
	//   because it means that there is no leader
	//
	//
	// Follower receives Follower.PROPOSAL:
	//
	//   i) Ignore Follower.PROPOSAL
	//      if there is no known leader
	//
	//   ii) Send Follower.PROPOSAL to its Leader
	//
	//       Follower.PROPOSAL.To = Leader
	//       Follower.PROPOSAL.Entries = Entries
	//
	//
	// (etcd: raft.raftpb.MsgProp)
	PROPOSAL = 7;

	// LEADER_APPEND_REQUEST message is only sent by Leader.
	//
	//   newLogIndex   = Leader.Follower.Progress.Next
	//   prevLogIndex  = newLogsIndex - 1
	//   prevLogTerm   = Leader.raftLog.term(prevLogIndex)
	//   entries       = Leader.raftLog.entries(newLogIndex, Leader.maxMsgSize)
	//   leaderCommit  = Leader.raftLog.CommittedIndex
	//
	//   Leader.LEADER_APPEND_REQUEST.CurrentCommittedIndex = leaderCommit
	//   Leader.LEADER_APPEND_REQUEST.LogIndex              = prevLogIndex
	//   Leader.LEADER_APPEND_REQUEST.LogTerm               = prevLogTerm
	//   Leader.LEADER_APPEND_REQUEST.Entries               = entries
	//
	// (etcd: raft.raftpb.MsgApp)
	LEADER_APPEND_REQUEST = 8;

	// APPEND_RESPONSE message is the response to Leader by Follower.
	//
	//   i) response to LEADER_APPEND_REQUEST:
	//
	//      IF
	//         Follower.raftLog.CommittedIndex > Leader.LEADER_APPEND_REQUEST.LogIndex
	//
	//      THEN
	//         Follower.APPEND_RESPONSE.To       = Leader
	//         Follower.APPEND_RESPONSE.LogIndex = Follower.raftLog.CommittedIndex
	//         Follower.APPEND_RESPONSE.Reject   = false
	//
	//      AND THEN
	//         Leader updates Leader.Follower.Progress
	//
	//      ELSE IF
	//         Leader.LEADER_APPEND_REQUEST.LogIndex >= Follower.raftLog.CommittedIndex
	//
	//      AND IF
	//         term1 = Leader.LEADER_APPEND_REQUEST.LogTerm
	//         term2 = Follower.term(Leader.LEADER_APPEND_REQUEST.LogIndex)
	//         term1 == term2
	//
	//         THEN
	//            idx1 = Leader.LEADER_APPEND_REQUEST.CurrentCommittedIndex
	//            idx2 = Leader.LEADER_APPEND_REQUEST.LogIndex + len(new entries)
	//            Follower.raftLog.commitTo(min(idx1, idx2))
	//
	//            Follower.APPEND_RESPONSE.To       = Leader
	//            Follower.APPEND_RESPONSE.LogIndex = idx2
	//            Follower.APPEND_RESPONSE.Reject   = false
	//
	//      ELSE
	//         Follower.APPEND_RESPONSE.To         = Leader
	//         Follower.APPEND_RESPONSE.LogIndex   = Leader.LEADER_APPEND_REQUEST.LogIndex
	//         Follower.APPEND_RESPONSE.Reject     = true
	//         Follower.APPEND_RESPONSE.RejectHint = Follower.raftLog.lastIndex()
	//
	//         THEN
	//            Leader gets this Rejection and updates its Progress with:
	//               idx1 = Follower.APPEND_RESPONSE.LogIndex
	//               idx2 = Follower.APPEND_RESPONSE.RejectHint + 1
	//               Leader.Follower.Progress.Next = min(idx1, idx2)
	//
	//   (etcd: raft.*raft.handleAppendEntries)
	//
	//
	//   ii) response to LEADER_SNAPSHOT_REQUEST
	//
	//      IF
	//         idx1 = Follower.raftLog.CommittedIndex
	//         idx2 = Leader.LEADER_SNAPSHOT_REQUEST.Index
	//         idx1 >= idx2
	//            THEN false
	//
	//         idx   = Leader.LEADER_SNAPSHOT_REQUEST.Index
	//         term1 = Follower.raftLog.term(Leader.LEADER_SNAPSHOT_REQUEST.Index)
	//         term2 = Leader.LEADER_SNAPSHOT_REQUEST.Term
	//         term1 == term2
	//            THEN Follower.raftLog.commitTo(idx)
	//            AND THEN false
	//
	//      ELSE
	//         true
	//
	//      IF true, THEN successfully recovered the state machine from a snapshot
	//         Follower.APPEND_RESPONSE.To       = Leader
	//         Follower.APPEND_RESPONSE.LogIndex = Follower.raftLog.lastIndex()
	//         Follower.APPEND_RESPONSE.Reject   = false
	//
	//      ELSE ignores snapshot
	//         Follower.APPEND_RESPONSE.To       = Leader
	//         Follower.APPEND_RESPONSE.LogIndex = Follower.raftLog.CommittedIndex
	//         Follower.APPEND_RESPONSE.Reject   = false
	//
	//   (etcd: raft.*raft.handleSnapshot)
	//
	//
	//   iii)
	//      term1 = Follower.Term
	//      term2 = Leader.LEADER_HEARTBEAT_REQUEST.LogTerm
	//      term3 = Leader.LEADER_APPEND_REQUEST.LogTerm
	//      term1 > term2 || term1 > term3
	//
	//         THEN
	//            Follower received message from Leader with a lower term
	//         SO
	//            Follower ignores this message
	//
	//   (etcd: raft.*raft.Step)
	//
	//
	// (etcd: raft.raftpb.MsgAppResp)
	APPEND_RESPONSE = 9;

	// LEADER_SNAPSHOT_REQUEST is only sent by Leader.
	// It is triggered when the Leader tries to replicate its log (sendAppend) but:
	//
	//   i) term, err = Leader.raftLog.term(Leader.Follower.Progress.Next - 1)
	//      err == ErrCompacted
	//
	//   OR
	//
	//   ii) entries, err = Leader.raftLog.entries(Leader.Follower.Progress.Next, Leader.maxMsgSize)
	//       err != nil
	//
	//   THEN
	//      snap = Leader.raftLog.snapshot()
	//      Leader.LEADER_SNAPSHOT_REQUEST.Snapshot = snap
	//      Leader.Follower.Progress.becomeSnapshot(snap.Index)
	//
	//
	// (etcd: raft.raftpb.MsgSnap)
	LEADER_SNAPSHOT_REQUEST = 10;

	// INTERNAL_SNAPSHOT_RESPONSE message is the response to LEADER_SNAPSHOT_REQUEST from Follower.
	//
	// It is an internal(local) message that is never sent to other peers over the network.
	//
	// (etcd: raft.raftpb.MsgSnapStatus)
	INTERNAL_SNAPSHOT_RESPONSE = 11;

	// INTERNAL_UNREACHABLE_FOLLOWER message notifies Leader that Follower is not reachable.
	//
	// It is an internal(local) message that is never sent to other peers over the network.
	//
	// (etcd: raft.raftpb.MsgUnreachable)
	INTERNAL_UNREACHABLE_FOLLOWER = 12;

	// INTERNAL_LEADER_TRANSFER message allows Leader to transfer its leadership to another.
	//
	// It is an internal(local) message that is never sent to other peers over the network.
	//
	// (etcd: raft.raftpb.MsgTransferLeader)
	INTERNAL_LEADER_TRANSFER = 13;

	// FORCE_ELECTION_TIMEOUT message makes Leader send time-out message to its peers,
	// so that Follower can force election timeouts and start campaigning. Candidate
	// is already campaigning, so it ignores this message. It is used when the leader
	// transfer is happening.
	//
	// (etcd: raft.raftpb.MsgTimeoutNow)
	FORCE_ELECTION_TIMEOUT = 14;

	// LEADER_CURRENT_COMMITTED_INDEX_REQUEST is used to serve clients' read-only queries without
	// going through Raft, but still with 'quorum-get' on. It bypasses the Raft log, but
	// still preserves the linearizability of reads, with lower costs.
	//
	// If a request goes through Raft log, it needs replication, which requires synchronous
	// disk writes in order to append those request entries to its log. Since read-only requests
	// do not change any state of replicated state machine, these writes can be time- and
	// resource-consuming.
	//
	// To bypass the Raft log with linearizable reads:
	//
	//   1. If Leader has not yet committed an entry from CurrentTerm, it waits until it has done so.
	//
	//   2. Leader saves its CurrentCommittedIndex in a local variable 'readIndex', which is used
	//      as a lower bound for the version of the state that read-only queries operate against.
	//
	//   3. Leader must ensure that it hasn't been superseded by a newer Leader,
	//      by issuing a new round of heartbeats and waiting for responses from cluster quorum.
	//
	//   4. These responses from Followers acknowledging the Leader indicates that
	//      there was no other Leader at the moment Leader sent out heartbeats.
	//
	//   5. Therefore, Leader's 'readIndex' was, at the time, the largest committed index,
	//      ever seen by any node in the cluster.
	//
	//   6. Leader now waits for its state machine to advance at least as far as the 'readIndex'.
	//      And this is current enought to satisfy linearizability.
	//
	//   7. Leader can now respond to those read-only client requests.
	//
	// (Raft 6.4 Processing read-only queries more efficiently, page 72)
	// (etcd: raft.raftpb.MsgReadIndex)
	LEADER_CURRENT_COMMITTED_INDEX_REQUEST = 15;

	// LEADER_CURRENT_COMMITTED_INDEX_RESPONSE is response to LEADER_CURRENT_COMMITTED_INDEX_REQUEST.
	//
	// (Raft 6.4 Processing read-only queries more efficiently, page 72)
	// (etcd: raft.raftpb.MsgReadIndexResp)
	LEADER_CURRENT_COMMITTED_INDEX_RESPONSE = 16;
}

// Message contains messages between nodes.
message Message {
	// Type defines the type of Message.
	MESSAGE_TYPE Type = 1;

	// From is the ID of the sender node.
	// (etcd: raft.raftpb.Message.From)
	uint64 From = 2;

	// To is the ID of the receiver node.
	// (etcd: raft.raftpb.Message.To)
	uint64 To   = 3;

	// CurrentCommittedIndex is the index of highest log entry that is known to be
	// committed (initialized to 0, increasing monotonically). It is the
	// highest log position that is known to be in stable storage on a
	// quorum of nodes in the cluster.
	//
	//
	// Leader updates CurrentCommittedIndex when sending out AppendEntries:
	//
	//   Leader.Message.CurrentCommittedIndex = Leader.raftLog.committed
	//
	// (etcd: raft.*raft.sendAppend with raftpb.MsgApp)
	//
	//
	// Follower receives/reads Leader.CurrentCommittedIndex in AppendEntries
	// and AppendEntries is only successful when:
	//
	//   i) Follower.raftLog.CommittedIndex > Leader.Message.LogIndex
	//   (etcd: raft.*raft.handleAppendEntries, raft.*Progress.maybeUpdate)
	//
	//   OR
	//
	//   ii) Follower.term(Leader.LogIndex) == Leader.Message.LogTerm
	//
	//   Conflicts:
	//
	//      Follower.term(Leader.Message.Entries[i].Index)
	//         != Leader.Message.Entries[i].Term
	//
	//   Then overwrite with Leader's log.
	//
	//   idx1 = Leader.Message.CurrentCommittedIndex
	//   idx2 = Leader.Message.LogIndex + len(Leader.Message.Entries)
	//   Follower.raftLog.commitTo(min(idx1, idx2))
	//
	//   (etcd: raft.*raftLog.maybeAppend)
	//
	//
	// (etcd: raft.raftpb.Message.Commit)
	uint64 CurrentCommittedIndex = 4;

	// CurrentTerm is the latest term that server has seen,
	// initialized to 0 on first boot, increasing monotonically.
	// CurrentTerm is 0 for local messages.
	//
	// CurrentTerm gets updated whenever node sends out messages.
	//
	// If a node receives a message with higher CurrentTerm,
	// it reverts back to Follower.
	// (etcd: raft.Step)
	//
	// If a node receives a message with lower CurrentTerm,
	// it ignores that message.
	// (etcd: raft.Step)
	//
	// Candidate starts an election by increasing CurrentTerm by 1.
	//
	// Follower overwrites its CurrentTerm with leader's CurrentTerm.
	//
	// (etcd: raft.raftpb.Message.Term)
	uint64 CurrentTerm = 5;

	// LogIndex is the index of log entry immediately preceding the new ones.
	//
	//
	// Leader updates Leader.LogIndex when sending out:
	//
	//   i) RequestVote with:
	//
	//      Leader.Message.LogIndex = Leader.raftLog.lastIndex()
	//      Leader.Message.LogTerm  = Leader.raftLog.lastTerm()
	//
	//   so that Follower can reject or not.
	//   (etcd: raft.*raft.campaign with raftpb.MsgVote)
	//
	//   OR
	//
	//   ii) AppendEntries with:
	//
	//      Leader.Message.LogIndex = Leader.Follower.Progress.Next - 1
	//      Leader.Message.LogTerm  = Leader.raftLog.term(Leader.Follower.Progress.Next - 1)
	//
	//   to tell its Follower where those new entries start.
	//   (etcd: raft.*raft.sendAppend with raftpb.MsgApp)
	//
	//
	// Follower rejects RequestVote when:
	//
	//   i) Follower.raftLog.lastTerm() > Leader.Message.LogTerm
	//   (etcd: raft.stepFollower with raftpb.MsgVoteResp)
	//
	//   AND
	//
	//   ii) Follower.raftLog.lastIndex() > Leader.Message.LogIndex
	//   (etcd: raft.stepFollower with raftpb.MsgVoteResp)
	//
	//
	// Follower rejects AppendEntries when:
	//
	//   Follower.term(Leader.LogIndex) != Leader.Message.LogTerm
	//
	// (etcd: raft.*raft.handleAppendEntries, maybeAppend)
	//
	//
	// (etcd: raft.raftpb.Message.Index)
	uint64 LogIndex = 6;

	// LogTerm is the term of LogIndex, where new log entries start.
	//
	//
	// Leader updates Message.LogTerm when sending out:
	//
	//   AppendEntries with:
	//
	//      Leader.Message.LogIndex = Leader.Follower.Progress.Next - 1
	//      Leader.Message.LogTerm  = Leader.raftLog.term(Leader.Follower.Progress.Next - 1)
	//
	//   to tell followers where new log entries start.
	//   New log entries start from Leader.Follower.Progress.Next.
	//   (etcd: raft.*raft.sendAppend with raftpb.MsgApp)
	//
	//
	// Candidate updates Message.LogTerm when sending out:
	//
	//   RequestVote with:
	//
	//      Leader.Message.LogIndex = Follower.raftLog.lastIndex()
	//      Leader.Message.LogTerm  = Follower.raftLog.lastTerm()
	//
	//   (etcd: raft.*raft.campaign with raftpb.MsgVote)
	//
	//
	// Follower receives/reads Leader.Message.LogTerm:
	//
	//   1. When receiving RequestVote from Leader:
	//
	//   Follower only accepts the message when Leader's log is more up-to-date.
	//
	//      i)  Leader.Message.LogTerm > Follower.raftLog.lastTerm()
	//
	//      OR
	//
	//      ii) Leader.Message.LogIndex >= Follower.raftLog.lastIndex()
	//          AND
	//          Leader.Message.LogTerm  == Follower.raftLog.lastTerm()
	//
	//   (etcd: raft.*raftLog.isUpToDate with raftpb.MsgVoteResp)
	//
	//
	//   2. When Follower receives AppendEntries from Leader:
	//   AppendEntries is only successful when:
	//
	//      i)  Follower.raftLog.CommittedIndex > Leader.Message.LogIndex
	//
	//      to tell Follower is ahead of that message, so Follower ignores
	//      this Message, and Leader can update Leader.Follower.Progress.Next.
	//
	//      It will respond with:
	//         - To: Leader
	//         - Type: raftpb.MsgAppResp
	//         - LogIndex: Follower.raftLog.CommittedIndex
	//
	//      (etcd: raft.*raft.handleAppendEntries, raft.*Progress.maybeUpdate)
	//
	//      OR
	//
	//      ii) Follower.term(Leader.LogIndex) == Leader.Message.LogTerm
	//
	//      Otherwise, rejects AppendEntries RPC and responds to leader with:
	//         - To: Leader
	//         - Type: raftpb.MsgAppResp
	//         - LogIndex: Leader.Message.LogIndex
	//         - Reject: true
	//         - RejectHint: Follower.raftLog.lastIndex()
	//
	//      Conflicts:
	//
	//         Follower.term(Leader.Message.Entries[i].Index)
	//            != Leader.Message.Entries[i].Term
	//
	//      Then overwrite with Leader's log.
	//
	//      idx1 = Leader.Message.CommittedIndex
	//      idx2 = Leader.Message.LogIndex + len(Leader.Message.Entries)
	//      Follower.raftLog.commitTo(min(idx1, idx2))
	//
	//      (etcd: raft.*raft.handleAppendEntries, maybeAppend)
	//
	//
	// (etcd: raft.raftpb.Message.LogTerm)
	uint64 LogTerm = 7;

	// Entries is an array of Entry. They are stored in stable storage
	// before messages are sent.
	//
	// (etcd: raft.raftpb.Message.Entries)
	repeated Entry Entries = 8 [(gogoproto.nullable) = false]; // generate without pointer

	// Snapshot represents current in-memory state of the server.
	// It is stored in stable storage before messages are sent.
	//
	// To prevent logs from growing unbounded, Raft servers compact their
	// logs when the quorum of cluster is available. But when the unavailable
	// minority of servers become available, they need to catch up, by
	// receiving the snapshots from leader, because those missing log entries
	// are possibly gone forever (compacted). So servers sometimes sends snapshots
	// to each other across the network. Write-ahead log approach continuously
	// snapshots to the disk.
	//
	// When the leader decides to snapshot, it first logs a special start
	// entry. For slow followers, the leader will have to send an AppendEntries
	// RPC to the follower with an entry that the leader has already discarded
	// (compacted). In this case, the follower should just discard its entire
	// state. The leader will send the follower the log entries beginning with
	// the start entry.
	//
	// (etcd: raft.raftpb.Message.Snapshot)
	Snapshot Snapshot = 9 [(gogoproto.nullable) = false]; // generate without pointer

	// Reject is true when rejecting Message.
	// (etcd: raft.raftpb.Message.Reject, raftpb.MsgVoteResp)
	bool Reject = 10;

	// RejectHintFollowerLastIndex is used to tell Leader the correct last index of Follower.
	//
	// Follower sets:
	//
	//   Follower.Message.Type       = raftpb.MsgAppResp
	//   Follower.Message.LogIndex   = Leader.Message.LogIndex
	//   Follower.Message.Reject     = true
	//   Follower.Message.RejectHintFollowerLastIndex = Follower.raftLog.lastIndex()
	//
	//   (etcd: raft.*raft.handleAppendEntries)
	//
	// Then Leader receives this Mesasge with Message.Reject,
	// and decreases(updates):
	//
	//   idx1 = Follower.Message.LogIndex
	//   idx2 = Follower.Message.RejectHintFollowerLastIndex
	//   Leader.Follower.Progress.Next = min(idx1, idx2)
	//
	//   (etcd: raft.stepLeader with raftpb.MsgAppResp)
	//
	//
	// (etcd: raft.raftpb.Message.RejectHint, raftpb.MsgAppResp)
	uint64 RejectHintFollowerLastIndex = 11;
}
