// Code generated by protoc-gen-gogo.
// source: raft/raftpb/raftpb.proto
// DO NOT EDIT!

/*
	Package raftpb is a generated protocol buffer package.

	It is generated from these files:
		raft/raftpb/raftpb.proto
		raft/raftpb/state.proto

	It has these top-level messages:
		Entry
		ConfigState
		SnapshotMetadata
		Snapshot
		HardState
		ConfigChange
		Message
		SoftState
*/
package raftpb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// (etcd raftpb.EntryType)
type ENTRY_TYPE int32

const (
	ENTRY_TYPE_NORMAL        ENTRY_TYPE = 0
	ENTRY_TYPE_CONFIG_CHANGE ENTRY_TYPE = 1
)

var ENTRY_TYPE_name = map[int32]string{
	0: "NORMAL",
	1: "CONFIG_CHANGE",
}
var ENTRY_TYPE_value = map[string]int32{
	"NORMAL":        0,
	"CONFIG_CHANGE": 1,
}

func (x ENTRY_TYPE) String() string {
	return proto.EnumName(ENTRY_TYPE_name, int32(x))
}
func (ENTRY_TYPE) EnumDescriptor() ([]byte, []int) { return fileDescriptorRaftpb, []int{0} }

// (etcd raftpb.ConfChangeType)
type CONFIG_CHANGE_TYPE int32

const (
	CONFIG_CHANGE_TYPE_ADD_NODE    CONFIG_CHANGE_TYPE = 0
	CONFIG_CHANGE_TYPE_REMOVE_NODE CONFIG_CHANGE_TYPE = 1
	CONFIG_CHANGE_TYPE_UPDATE_NODE CONFIG_CHANGE_TYPE = 2
)

var CONFIG_CHANGE_TYPE_name = map[int32]string{
	0: "ADD_NODE",
	1: "REMOVE_NODE",
	2: "UPDATE_NODE",
}
var CONFIG_CHANGE_TYPE_value = map[string]int32{
	"ADD_NODE":    0,
	"REMOVE_NODE": 1,
	"UPDATE_NODE": 2,
}

func (x CONFIG_CHANGE_TYPE) String() string {
	return proto.EnumName(CONFIG_CHANGE_TYPE_name, int32(x))
}
func (CONFIG_CHANGE_TYPE) EnumDescriptor() ([]byte, []int) { return fileDescriptorRaftpb, []int{1} }

// (etcd raftpb.MessageType)
type MESSAGE_TYPE int32

const (
	// INTERNAL_CAMPAIGN_START message is used locally by Candidate/Follower
	// to start an election after election timeout.
	//
	// Every server in Raft starts as a follower, and when it has not received
	// any message from a valid leader before the randomized election timeout,
	// it will start an election to become a leader. To begin an election, a
	// follower increments its current term and becomes or remains Candidate.
	// Then votes for itself and send RequestVote RPCs in parallel to other peers.
	// (Raft 3.4 Leader election)
	//
	// It is an internal(local) message that is never sent to other peers over the network.
	//
	// (etcd: raft.raftpb.MsgHup)
	MESSAGE_TYPE_INTERNAL_CAMPAIGN_START MESSAGE_TYPE = 0
	// INTERNAL_LEADER_SEND_HEARTBEAT message is used locally by Leader,
	// to signal the leader to send a LEADER_HEARTBEAT_REQUEST to its followers.
	// It is triggered periodically after heartbeat timeouts.
	//
	// It is an internal(local) message that is never sent to other peers over the network.
	//
	// (etcd: raft.raftpb.MsgBeat)
	MESSAGE_TYPE_INTERNAL_LEADER_SEND_HEARTBEAT MESSAGE_TYPE = 1
	// INTERNAL_CHECK_QUORUM message is used locally by Leader,
	// to check if quorum of cluster (including itself) is active.
	// And if not, the leader steps down to a follower.
	//
	// Quorum is cluster size / 2 + 1.
	//
	// It is an internal(local) message that is never sent to other peers over the network.
	//
	// (etcd: raft.raftpb.MsgCheckQuorum)
	MESSAGE_TYPE_INTERNAL_CHECK_QUORUM MESSAGE_TYPE = 2
	// LEADER_HEARTBEAT_REQUEST message is heartbeat from the Leader.
	// It is triggered by INTERNAL_LEADER_SEND_HEARTBEAT message, after every heartbeat
	// timeout, and is sent to leader's followers. It is same as an empty
	// raftpb.MsgApp, but includes raftpb.Message.Commit information for
	// followers.
	//
	//   idx1 = Leader.Follower.Progress.Match
	//   idx2 = Leader.raftLog.CommittedIndex
	//   Leader.LEADER_HEARTBEAT_REQUEST.CurrentCommittedIndex = min(idx1, idx2)
	//
	// So that the followers can update their CommittedIndex.
	//
	// (etcd: raft.raftpb.MsgHeartbeat)
	MESSAGE_TYPE_LEADER_HEARTBEAT_REQUEST MESSAGE_TYPE = 3
	// HEARTBEAT_RESPONSE message is the response from Follower,
	// for leader's LEADER_HEARTBEAT_REQUEST. It does not contain any information.
	// When a leader receives this message from a follower, the leader marks
	// this follower as active, and sends raftpb.MsgApp if needed.
	//
	// (etcd: raft.raftpb.MsgHeartbeatResp)
	MESSAGE_TYPE_HEARTBEAT_RESPONSE MESSAGE_TYPE = 4
	// CANDIDATE_VOTE_REQUEST message is sent by Candiate.
	// It is triggered by an election, and sent with the candidate's
	// information:
	//
	//   Candidate.CANDIDATE_VOTE_REQUEST.LogTerm  = Candidate.raftLog.lastTerm()
	//   Candidate.CANDIDATE_VOTE_REQUEST.LogIndex = Candidate.raftLog.lastIndex()
	//
	// (etcd: raft.raftpb.MsgVote)
	MESSAGE_TYPE_CANDIDATE_VOTE_REQUEST MESSAGE_TYPE = 5
	// VOTE_RESPONSE message is the response to CANDIDATE_VOTE_REQUEST.
	//
	//
	// Leader receives CANDIDATE_VOTE_REQUEST from Candidate, and then:
	//
	//   Leader.VOTE_RESPONSE.Reject = true
	//
	//
	// Candidate receives CANDIDATE_VOTE_REQUEST from another candidate, and then:
	//
	//   Candidate.VOTE_RESPONSE.Reject = true
	//
	//
	// Follower receives CANDIDATE_VOTE_REQUEST from Candidate, and IF:
	//
	//   i) Candidate.Message.LogTerm > Follower.raftLog.lastTerm()
	//   OR
	//   ii) Candidate.Message.LogTerm == Follower.raftLog.lastTerm()
	//       AND
	//       Candidate.Message.LogIndex >= Follower.raftLog.lastIndex()
	//
	//   THEN
	//      Follower.VOTE_RESPONSE.To     = Candidate
	//      Follower.VOTE_RESPONSE.Reject = false
	//
	//   ELSE
	//      Follower.VOTE_RESPONSE.To     = Candidate
	//      Follower.VOTE_RESPONSE.Reject = true
	//
	// (etcd: raft.raftpb.MsgVoteResp)
	MESSAGE_TYPE_VOTE_RESPONSE MESSAGE_TYPE = 6
	// PROPOSAL message is used to forward client requests to its
	// leader, because client requests in Raft are processed through the
	// leader. First option is for the server to reject the request and
	// return the endpoint of the leader to the client. Or the server can proxy
	// the client's requests to the leader without rejection, so that clients
	// can talk to any node in the cluster.
	// (Raft 6.2 Routing requests to the leader)
	//
	// For Leader/Candidate, it is an internal(local) message that is never
	// sent to other peers over the network. For Follower, it is forwarded
	// to Leader over the network.
	//
	// It is triggered whenever local node.Propose, only contains:
	//
	//   Leader/Candidate/Follower.PROPOSAL.Entries = Entries
	//
	//
	// Leader receives Leader.PROPOSAL:
	//
	//   Leader.appendEntry(Leader.PROPOSAL.Entries)
	//   Leader.bcastAppend() to followers
	//
	//
	// Candidate receives Candidate.PROPOSAL:
	//
	//   Ignore Candidate.PROPOSAL
	//   because it means that there is no leader
	//
	//
	// Follower receives Follower.PROPOSAL:
	//
	//   i) Ignore Follower.PROPOSAL
	//      if there is no known leader
	//
	//   ii) Send Follower.PROPOSAL to its Leader
	//
	//       Follower.PROPOSAL.To = Leader
	//       Follower.PROPOSAL.Entries = Entries
	//
	//
	// (etcd: raft.raftpb.MsgProp)
	MESSAGE_TYPE_PROPOSAL MESSAGE_TYPE = 7
	// LEADER_APPEND_REQUEST message is only sent by Leader.
	//
	//   newLogIndex   = Leader.Follower.Progress.Next
	//   prevLogIndex  = newLogsIndex - 1
	//   prevLogTerm   = Leader.raftLog.term(prevLogIndex)
	//   entries       = Leader.raftLog.entries(newLogIndex, Leader.maxMsgSize)
	//   leaderCommit  = Leader.raftLog.CommittedIndex
	//
	//   Leader.LEADER_APPEND_REQUEST.CurrentCommittedIndex = leaderCommit
	//   Leader.LEADER_APPEND_REQUEST.LogIndex              = prevLogIndex
	//   Leader.LEADER_APPEND_REQUEST.LogTerm               = prevLogTerm
	//   Leader.LEADER_APPEND_REQUEST.Entries               = entries
	//
	// (etcd: raft.raftpb.MsgApp)
	MESSAGE_TYPE_LEADER_APPEND_REQUEST MESSAGE_TYPE = 8
	// APPEND_RESPONSE message is the response to Leader by Follower.
	//
	//   i) response to LEADER_APPEND_REQUEST:
	//
	//      IF
	//         Follower.raftLog.CommittedIndex > Leader.LEADER_APPEND_REQUEST.LogIndex
	//
	//      THEN
	//         Follower.APPEND_RESPONSE.To       = Leader
	//         Follower.APPEND_RESPONSE.LogIndex = Follower.raftLog.CommittedIndex
	//         Follower.APPEND_RESPONSE.Reject   = false
	//
	//      AND THEN
	//         Leader updates Leader.Follower.Progress
	//
	//      ELSE IF
	//         Leader.LEADER_APPEND_REQUEST.LogIndex >= Follower.raftLog.CommittedIndex
	//
	//      AND IF
	//         term1 = Leader.LEADER_APPEND_REQUEST.LogTerm
	//         term2 = Follower.term(Leader.LEADER_APPEND_REQUEST.LogIndex)
	//         term1 == term2
	//
	//         THEN
	//            idx1 = Leader.LEADER_APPEND_REQUEST.CurrentCommittedIndex
	//            idx2 = Leader.LEADER_APPEND_REQUEST.LogIndex + len(new entries)
	//            Follower.raftLog.commitTo(min(idx1, idx2))
	//
	//            Follower.APPEND_RESPONSE.To       = Leader
	//            Follower.APPEND_RESPONSE.LogIndex = idx2
	//            Follower.APPEND_RESPONSE.Reject   = false
	//
	//      ELSE
	//         Follower.APPEND_RESPONSE.To         = Leader
	//         Follower.APPEND_RESPONSE.LogIndex   = Leader.LEADER_APPEND_REQUEST.LogIndex
	//         Follower.APPEND_RESPONSE.Reject     = true
	//         Follower.APPEND_RESPONSE.RejectHint = Follower.raftLog.lastIndex()
	//
	//         THEN
	//            Leader gets this Rejection and updates its Follower.Progress with:
	//               idx1 = Follower.APPEND_RESPONSE.LogIndex
	//               idx2 = Follower.APPEND_RESPONSE.RejectHint + 1
	//               Leader.Follower.Progress.Next = min(idx1, idx2)
	//
	//   (etcd: raft.*raft.handleAppendEntries)
	//
	//
	//   ii) response to LEADER_SNAPSHOT_REQUEST
	//
	//      IF
	//         idx1 = Follower.raftLog.CommittedIndex
	//         idx2 = Leader.LEADER_SNAPSHOT_REQUEST.Index
	//         idx1 >= idx2
	//            THEN false
	//
	//         idx   = Leader.LEADER_SNAPSHOT_REQUEST.Index
	//         term1 = Follower.raftLog.term(Leader.LEADER_SNAPSHOT_REQUEST.Index)
	//         term2 = Leader.LEADER_SNAPSHOT_REQUEST.Term
	//         term1 == term2
	//            THEN Follower.raftLog.commitTo(idx)
	//            AND THEN false
	//
	//      ELSE
	//         true
	//
	//      IF true, THEN successfully recovered the state machine from a snapshot
	//         Follower.APPEND_RESPONSE.To       = Leader
	//         Follower.APPEND_RESPONSE.LogIndex = Follower.raftLog.lastIndex()
	//         Follower.APPEND_RESPONSE.Reject   = false
	//
	//      ELSE ignores snapshot
	//         Follower.APPEND_RESPONSE.To       = Leader
	//         Follower.APPEND_RESPONSE.LogIndex = Follower.raftLog.CommittedIndex
	//         Follower.APPEND_RESPONSE.Reject   = false
	//
	//   (etcd: raft.*raft.handleSnapshot)
	//
	//
	//   iii)
	//      term1 = Follower.Term
	//      term2 = Leader.LEADER_HEARTBEAT_REQUEST.LogTerm
	//      term3 = Leader.LEADER_APPEND_REQUEST.LogTerm
	//      term1 > term2 || term1 > term3
	//
	//         THEN
	//            Follower received message from Leader with a lower term
	//         SO
	//            Follower ignores this message
	//
	//   (etcd: raft.*raft.Step)
	//
	//
	// (etcd: raft.raftpb.MsgAppResp)
	MESSAGE_TYPE_APPEND_RESPONSE MESSAGE_TYPE = 9
	// LEADER_SNAPSHOT_REQUEST is only sent by Leader.
	// It is triggered when the Leader tries to replicate its log (sendAppend) but:
	//
	//   i) term, err = Leader.raftLog.term(Leader.Follower.Progress.Next - 1)
	//      err == ErrCompacted
	//
	//   OR
	//
	//   ii) entries, err = Leader.raftLog.entries(Leader.Follower.Progress.Next, Leader.maxMsgSize)
	//       err != nil
	//
	//   THEN
	//      snap = Leader.raftLog.snapshot()
	//      Leader.LEADER_SNAPSHOT_REQUEST.Snapshot = snap
	//      Leader.Follower.Progress.becomeSnapshot(snap.Index)
	//
	//
	// (etcd: raft.raftpb.MsgSnap)
	MESSAGE_TYPE_LEADER_SNAPSHOT_REQUEST MESSAGE_TYPE = 10
	// INTERNAL_SNAPSHOT_RESPONSE message is the response to LEADER_SNAPSHOT_REQUEST from Follower.
	//
	// It is an internal(local) message that is never sent to other peers over the network.
	//
	// (etcd: raft.raftpb.MsgSnapStatus)
	MESSAGE_TYPE_INTERNAL_SNAPSHOT_RESPONSE MESSAGE_TYPE = 11
	// INTERNAL_UNREACHABLE_FOLLOWER message notifies Leader that Follower is not reachable.
	//
	// It is an internal(local) message that is never sent to other peers over the network.
	//
	// (etcd: raft.raftpb.MsgUnreachable)
	MESSAGE_TYPE_INTERNAL_UNREACHABLE_FOLLOWER MESSAGE_TYPE = 12
	// INTERNAL_LEADER_TRANSFER message allows Leader to transfer its leadership to another.
	//
	// It is an internal(local) message that is never sent to other peers over the network.
	//
	// (etcd: raft.raftpb.MsgTransferLeader)
	MESSAGE_TYPE_INTERNAL_LEADER_TRANSFER MESSAGE_TYPE = 13
	// FORCE_ELECTION_TIMEOUT message makes Leader send time-out message to its peers,
	// so that Follower can force election timeouts and start campaigning. Candidate
	// is already campaigning, so it ignores this message. It is used when the leader
	// transfer is happening.
	//
	// (etcd: raft.raftpb.MsgTimeoutNow)
	MESSAGE_TYPE_FORCE_ELECTION_TIMEOUT MESSAGE_TYPE = 14
	// LEADER_CURRENT_COMMITTED_INDEX_REQUEST is used to serve clients' read-only queries without
	// going through Raft, but still with 'quorum-get' on. It bypasses the Raft log, but
	// still preserves the linearizability of reads, with lower costs.
	//
	// If a request goes through Raft log, it needs replication, which requires synchronous
	// disk writes in order to append those request entries to its log. Since read-only requests
	// do not change any state of replicated state machine, these writes can be time- and
	// resource-consuming.
	//
	// To bypass the Raft log with linearizable reads:
	//
	//   1. If Leader has not yet committed an entry from CurrentTerm, it waits until it has done so.
	//
	//   2. Leader saves its CurrentCommittedIndex in a local variable 'readIndex', which is used
	//      as a lower bound for the version of the state that read-only queries operate against.
	//
	//   3. Leader must ensure that it hasn't been superseded by a newer Leader,
	//      by issuing a new round of heartbeats and waiting for responses from cluster quorum.
	//
	//   4. These responses from Followers acknowledging the Leader indicates that
	//      there was no other Leader at the moment Leader sent out heartbeats.
	//
	//   5. Therefore, Leader's 'readIndex' was, at the time, the largest committed index,
	//      ever seen by any node in the cluster.
	//
	//   6. Leader now waits for its state machine to advance at least as far as the 'readIndex'.
	//      And this is current enought to satisfy linearizability.
	//
	//   7. Leader can now respond to those read-only client requests.
	//
	// (Raft 6.4 Processing read-only queries more efficiently, page 72)
	// (etcd: raft.raftpb.MsgReadIndex)
	MESSAGE_TYPE_LEADER_CURRENT_COMMITTED_INDEX_REQUEST MESSAGE_TYPE = 15
	// LEADER_CURRENT_COMMITTED_INDEX_RESPONSE is response to LEADER_CURRENT_COMMITTED_INDEX_REQUEST.
	//
	// (Raft 6.4 Processing read-only queries more efficiently, page 72)
	// (etcd: raft.raftpb.MsgReadIndexResp)
	MESSAGE_TYPE_LEADER_CURRENT_COMMITTED_INDEX_RESPONSE MESSAGE_TYPE = 16
)

var MESSAGE_TYPE_name = map[int32]string{
	0:  "INTERNAL_CAMPAIGN_START",
	1:  "INTERNAL_LEADER_SEND_HEARTBEAT",
	2:  "INTERNAL_CHECK_QUORUM",
	3:  "LEADER_HEARTBEAT_REQUEST",
	4:  "HEARTBEAT_RESPONSE",
	5:  "CANDIDATE_VOTE_REQUEST",
	6:  "VOTE_RESPONSE",
	7:  "PROPOSAL",
	8:  "LEADER_APPEND_REQUEST",
	9:  "APPEND_RESPONSE",
	10: "LEADER_SNAPSHOT_REQUEST",
	11: "INTERNAL_SNAPSHOT_RESPONSE",
	12: "INTERNAL_UNREACHABLE_FOLLOWER",
	13: "INTERNAL_LEADER_TRANSFER",
	14: "FORCE_ELECTION_TIMEOUT",
	15: "LEADER_CURRENT_COMMITTED_INDEX_REQUEST",
	16: "LEADER_CURRENT_COMMITTED_INDEX_RESPONSE",
}
var MESSAGE_TYPE_value = map[string]int32{
	"INTERNAL_CAMPAIGN_START":                 0,
	"INTERNAL_LEADER_SEND_HEARTBEAT":          1,
	"INTERNAL_CHECK_QUORUM":                   2,
	"LEADER_HEARTBEAT_REQUEST":                3,
	"HEARTBEAT_RESPONSE":                      4,
	"CANDIDATE_VOTE_REQUEST":                  5,
	"VOTE_RESPONSE":                           6,
	"PROPOSAL":                                7,
	"LEADER_APPEND_REQUEST":                   8,
	"APPEND_RESPONSE":                         9,
	"LEADER_SNAPSHOT_REQUEST":                 10,
	"INTERNAL_SNAPSHOT_RESPONSE":              11,
	"INTERNAL_UNREACHABLE_FOLLOWER":           12,
	"INTERNAL_LEADER_TRANSFER":                13,
	"FORCE_ELECTION_TIMEOUT":                  14,
	"LEADER_CURRENT_COMMITTED_INDEX_REQUEST":  15,
	"LEADER_CURRENT_COMMITTED_INDEX_RESPONSE": 16,
}

func (x MESSAGE_TYPE) String() string {
	return proto.EnumName(MESSAGE_TYPE_name, int32(x))
}
func (MESSAGE_TYPE) EnumDescriptor() ([]byte, []int) { return fileDescriptorRaftpb, []int{2} }

// (etcd raftpb.Entry)
type Entry struct {
	Type  ENTRY_TYPE `protobuf:"varint,1,opt,name=Type,json=type,proto3,enum=raftpb.ENTRY_TYPE" json:"Type,omitempty"`
	Index uint64     `protobuf:"varint,2,opt,name=Index,json=index,proto3" json:"Index,omitempty"`
	Term  uint64     `protobuf:"varint,3,opt,name=Term,json=term,proto3" json:"Term,omitempty"`
	Data  []byte     `protobuf:"bytes,4,opt,name=Data,json=data,proto3" json:"Data,omitempty"`
}

func (m *Entry) Reset()                    { *m = Entry{} }
func (m *Entry) String() string            { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()               {}
func (*Entry) Descriptor() ([]byte, []int) { return fileDescriptorRaftpb, []int{0} }

// (etcd raftpb.ConfState)
type ConfigState struct {
	IDs []uint64 `protobuf:"varint,1,rep,name=IDs,json=iDs" json:"IDs,omitempty"`
}

func (m *ConfigState) Reset()                    { *m = ConfigState{} }
func (m *ConfigState) String() string            { return proto.CompactTextString(m) }
func (*ConfigState) ProtoMessage()               {}
func (*ConfigState) Descriptor() ([]byte, []int) { return fileDescriptorRaftpb, []int{1} }

// (etcd raftpb.SnapshotMetadata)
type SnapshotMetadata struct {
	ConfigState ConfigState `protobuf:"bytes,1,opt,name=ConfigState,json=configState" json:"ConfigState"`
	Index       uint64      `protobuf:"varint,2,opt,name=Index,json=index,proto3" json:"Index,omitempty"`
	Term        uint64      `protobuf:"varint,3,opt,name=Term,json=term,proto3" json:"Term,omitempty"`
}

func (m *SnapshotMetadata) Reset()                    { *m = SnapshotMetadata{} }
func (m *SnapshotMetadata) String() string            { return proto.CompactTextString(m) }
func (*SnapshotMetadata) ProtoMessage()               {}
func (*SnapshotMetadata) Descriptor() ([]byte, []int) { return fileDescriptorRaftpb, []int{2} }

// Snapshot contains snapshot data and meta-data.
// It is stored in stable storage before messages are sent.
type Snapshot struct {
	Metadata SnapshotMetadata `protobuf:"bytes,1,opt,name=Metadata,json=metadata" json:"Metadata"`
	Data     []byte           `protobuf:"bytes,2,opt,name=Data,json=data,proto3" json:"Data,omitempty"`
}

func (m *Snapshot) Reset()                    { *m = Snapshot{} }
func (m *Snapshot) String() string            { return proto.CompactTextString(m) }
func (*Snapshot) ProtoMessage()               {}
func (*Snapshot) Descriptor() ([]byte, []int) { return fileDescriptorRaftpb, []int{3} }

// HardState is the current state of the Raft node.
// It must be stored in stable storage before messages are sent.
//
// (etcd raftpb.HardState)
type HardState struct {
	VotedFor       uint64 `protobuf:"varint,1,opt,name=VotedFor,json=votedFor,proto3" json:"VotedFor,omitempty"`
	CommittedIndex uint64 `protobuf:"varint,2,opt,name=CommittedIndex,json=committedIndex,proto3" json:"CommittedIndex,omitempty"`
	Term           uint64 `protobuf:"varint,3,opt,name=Term,json=term,proto3" json:"Term,omitempty"`
}

func (m *HardState) Reset()                    { *m = HardState{} }
func (m *HardState) String() string            { return proto.CompactTextString(m) }
func (*HardState) ProtoMessage()               {}
func (*HardState) Descriptor() ([]byte, []int) { return fileDescriptorRaftpb, []int{4} }

// (etcd raftpb.ConfChange)
type ConfigChange struct {
	Type   CONFIG_CHANGE_TYPE `protobuf:"varint,1,opt,name=Type,json=type,proto3,enum=raftpb.CONFIG_CHANGE_TYPE" json:"Type,omitempty"`
	ID     uint64             `protobuf:"varint,2,opt,name=ID,json=iD,proto3" json:"ID,omitempty"`
	NodeID uint64             `protobuf:"varint,3,opt,name=NodeID,json=nodeID,proto3" json:"NodeID,omitempty"`
	Data   []byte             `protobuf:"bytes,4,opt,name=Data,json=data,proto3" json:"Data,omitempty"`
}

func (m *ConfigChange) Reset()                    { *m = ConfigChange{} }
func (m *ConfigChange) String() string            { return proto.CompactTextString(m) }
func (*ConfigChange) ProtoMessage()               {}
func (*ConfigChange) Descriptor() ([]byte, []int) { return fileDescriptorRaftpb, []int{5} }

// Message contains messages between nodes.
//
// (etcd raftpb.Message)
type Message struct {
	// Type defines the type of Message.
	Type MESSAGE_TYPE `protobuf:"varint,1,opt,name=Type,json=type,proto3,enum=raftpb.MESSAGE_TYPE" json:"Type,omitempty"`
	// From is the ID of the sender node.
	// (etcd: raft.raftpb.Message.From)
	From uint64 `protobuf:"varint,2,opt,name=From,json=from,proto3" json:"From,omitempty"`
	// To is the ID of the receiver node.
	// (etcd: raft.raftpb.Message.To)
	To uint64 `protobuf:"varint,3,opt,name=To,json=to,proto3" json:"To,omitempty"`
	// CurrentCommittedIndex is the index of highest log entry that is known to be
	// committed (initialized to 0, increasing monotonically). It is the
	// highest log position that is known to be in stable storage on a
	// quorum of nodes in the cluster.
	//
	//
	// Leader updates CurrentCommittedIndex when sending out AppendEntries:
	//
	//   Leader.Message.CurrentCommittedIndex = Leader.raftLog.committed
	//
	// (etcd: raft.*raft.sendAppend with raftpb.MsgApp)
	//
	//
	// Follower receives/reads Leader.CurrentCommittedIndex in AppendEntries
	// and AppendEntries is only successful when:
	//
	//   i) Follower.raftLog.CommittedIndex > Leader.Message.LogIndex
	//   (etcd: raft.*raft.handleAppendEntries, raft.*Progress.maybeUpdate)
	//
	//   OR
	//
	//   ii) Follower.term(Leader.LogIndex) == Leader.Message.LogTerm
	//
	//   Conflicts:
	//
	//      Follower.term(Leader.Message.Entries[i].Index)
	//         != Leader.Message.Entries[i].Term
	//
	//   Then overwrite with Leader's log.
	//
	//   idx1 = Leader.Message.CurrentCommittedIndex
	//   idx2 = Leader.Message.LogIndex + len(Leader.Message.Entries)
	//   Follower.raftLog.commitTo(min(idx1, idx2))
	//
	//   (etcd: raft.*raftLog.maybeAppend)
	//
	//
	// (etcd: raft.raftpb.Message.Commit)
	CurrentCommittedIndex uint64 `protobuf:"varint,4,opt,name=CurrentCommittedIndex,json=currentCommittedIndex,proto3" json:"CurrentCommittedIndex,omitempty"`
	// CurrentTerm is the latest term that server has seen,
	// initialized to 0 on first boot, increasing monotonically.
	// CurrentTerm is 0 for local messages.
	//
	// CurrentTerm gets updated whenever node sends out messages.
	//
	// If a node receives a message with higher CurrentTerm,
	// it reverts back to Follower.
	// (etcd: raft.Step)
	//
	// If a node receives a message with lower CurrentTerm,
	// it ignores that message.
	// (etcd: raft.Step)
	//
	// Candidate starts an election by increasing CurrentTerm by 1.
	//
	// Follower overwrites its CurrentTerm with leader's CurrentTerm.
	//
	// (etcd: raft.raftpb.Message.Term)
	CurrentTerm uint64 `protobuf:"varint,5,opt,name=CurrentTerm,json=currentTerm,proto3" json:"CurrentTerm,omitempty"`
	// LogIndex is the index of log entry immediately preceding the new ones.
	//
	//
	// Leader updates Leader.LogIndex when sending out:
	//
	//   i) RequestVote with:
	//
	//      Leader.Message.LogIndex = Leader.raftLog.lastIndex()
	//      Leader.Message.LogTerm  = Leader.raftLog.lastTerm()
	//
	//   so that Follower can reject or not.
	//   (etcd: raft.*raft.campaign with raftpb.MsgVote)
	//
	//   OR
	//
	//   ii) AppendEntries with:
	//
	//      Leader.Message.LogIndex = Leader.Follower.Progress.Next - 1
	//      Leader.Message.LogTerm  = Leader.raftLog.term(Leader.Follower.Progress.Next - 1)
	//
	//   to tell its Follower where those new entries start.
	//   (etcd: raft.*raft.sendAppend with raftpb.MsgApp)
	//
	//
	// Follower rejects RequestVote when:
	//
	//   i) Follower.raftLog.lastTerm() > Leader.Message.LogTerm
	//   (etcd: raft.stepFollower with raftpb.MsgVoteResp)
	//
	//   AND
	//
	//   ii) Follower.raftLog.lastIndex() > Leader.Message.LogIndex
	//   (etcd: raft.stepFollower with raftpb.MsgVoteResp)
	//
	//
	// Follower rejects AppendEntries when:
	//
	//   Follower.term(Leader.LogIndex) != Leader.Message.LogTerm
	//
	// (etcd: raft.*raft.handleAppendEntries, maybeAppend)
	//
	//
	// (etcd: raft.raftpb.Message.Index)
	LogIndex uint64 `protobuf:"varint,6,opt,name=LogIndex,json=logIndex,proto3" json:"LogIndex,omitempty"`
	// LogTerm is the term of LogIndex, where new log entries start.
	//
	//
	// Leader updates Message.LogTerm when sending out:
	//
	//   AppendEntries with:
	//
	//      Leader.Message.LogIndex = Leader.Follower.Progress.Next - 1
	//      Leader.Message.LogTerm  = Leader.raftLog.term(Leader.Follower.Progress.Next - 1)
	//
	//   to tell followers where new log entries start.
	//   New log entries start from Leader.Follower.Progress.Next.
	//   (etcd: raft.*raft.sendAppend with raftpb.MsgApp)
	//
	//
	// Candidate updates Message.LogTerm when sending out:
	//
	//   RequestVote with:
	//
	//      Leader.Message.LogIndex = Follower.raftLog.lastIndex()
	//      Leader.Message.LogTerm  = Follower.raftLog.lastTerm()
	//
	//   (etcd: raft.*raft.campaign with raftpb.MsgVote)
	//
	//
	// Follower receives/reads Leader.Message.LogTerm:
	//
	//   1. When receiving RequestVote from Leader:
	//
	//   Follower only accepts the message when Leader's log is more up-to-date.
	//
	//      i)  Leader.Message.LogTerm > Follower.raftLog.lastTerm()
	//
	//      OR
	//
	//      ii) Leader.Message.LogIndex >= Follower.raftLog.lastIndex()
	//          AND
	//          Leader.Message.LogTerm  == Follower.raftLog.lastTerm()
	//
	//   (etcd: raft.*raftLog.isUpToDate with raftpb.MsgVoteResp)
	//
	//
	//   2. When Follower receives AppendEntries from Leader:
	//   AppendEntries is only successful when:
	//
	//      i)  Follower.raftLog.CommittedIndex > Leader.Message.LogIndex
	//
	//      to tell Follower is ahead of that message, so Follower ignores
	//      this Message, and Leader can update Leader.Follower.Progress.Next.
	//
	//      It will respond with:
	//         - To: Leader
	//         - Type: raftpb.MsgAppResp
	//         - LogIndex: Follower.raftLog.CommittedIndex
	//
	//      (etcd: raft.*raft.handleAppendEntries, raft.*Follower.Progress.maybeUpdate)
	//
	//      OR
	//
	//      ii) Follower.term(Leader.LogIndex) == Leader.Message.LogTerm
	//
	//      Otherwise, rejects AppendEntries RPC and responds to leader with:
	//         - To: Leader
	//         - Type: raftpb.MsgAppResp
	//         - LogIndex: Leader.Message.LogIndex
	//         - Reject: true
	//         - RejectHint: Follower.raftLog.lastIndex()
	//
	//      Conflicts:
	//
	//         Follower.term(Leader.Message.Entries[i].Index)
	//            != Leader.Message.Entries[i].Term
	//
	//      Then overwrite with Leader's log.
	//
	//      idx1 = Leader.Message.CommittedIndex
	//      idx2 = Leader.Message.LogIndex + len(Leader.Message.Entries)
	//      Follower.raftLog.commitTo(min(idx1, idx2))
	//
	//      (etcd: raft.*raft.handleAppendEntries, maybeAppend)
	//
	//
	// (etcd: raft.raftpb.Message.LogTerm)
	LogTerm uint64 `protobuf:"varint,7,opt,name=LogTerm,json=logTerm,proto3" json:"LogTerm,omitempty"`
	// Entries is an array of Entry. They are stored in stable storage
	// before messages are sent.
	//
	// (etcd: raft.raftpb.Message.Entries)
	Entries []Entry `protobuf:"bytes,8,rep,name=Entries,json=entries" json:"Entries"`
	// Snapshot represents current in-memory state of the server.
	// It is stored in stable storage before messages are sent.
	//
	// To prevent logs from growing unbounded, Raft servers compact their
	// logs when the quorum of cluster is available. But when the unavailable
	// minority of servers become available, they need to catch up, by
	// receiving the snapshots from leader, because those missing log entries
	// are possibly gone forever (compacted). So servers sometimes sends snapshots
	// to each other across the network. Write-ahead log approach continuously
	// snapshots to the disk.
	//
	// When the leader decides to snapshot, it first logs a special start
	// entry. For slow followers, the leader will have to send an AppendEntries
	// RPC to the follower with an entry that the leader has already discarded
	// (compacted). In this case, the follower should just discard its entire
	// state. The leader will send the follower the log entries beginning with
	// the start entry.
	//
	// (etcd: raft.raftpb.Message.Snapshot)
	Snapshot Snapshot `protobuf:"bytes,9,opt,name=Snapshot,json=snapshot" json:"Snapshot"`
	// Reject is true when rejecting Message.
	// (etcd: raft.raftpb.Message.Reject, raftpb.MsgVoteResp)
	Reject bool `protobuf:"varint,10,opt,name=Reject,json=reject,proto3" json:"Reject,omitempty"`
	// RejectHintFollowerLastIndex is used to tell Leader the correct last index of Follower.
	//
	// Follower sets:
	//
	//   Follower.Message.Type       = raftpb.MsgAppResp
	//   Follower.Message.LogIndex   = Leader.Message.LogIndex
	//   Follower.Message.Reject     = true
	//   Follower.Message.RejectHintFollowerLastIndex = Follower.raftLog.lastIndex()
	//
	//   (etcd: raft.*raft.handleAppendEntries)
	//
	// Then Leader receives this Mesasge with Message.Reject,
	// and decreases(updates):
	//
	//   idx1 = Follower.Message.LogIndex
	//   idx2 = Follower.Message.RejectHintFollowerLastIndex
	//   Leader.Follower.Progress.Next = min(idx1, idx2)
	//
	//   (etcd: raft.stepLeader with raftpb.MsgAppResp)
	//
	//
	// (etcd: raft.raftpb.Message.RejectHint, raftpb.MsgAppResp)
	RejectHintFollowerLastIndex uint64 `protobuf:"varint,11,opt,name=RejectHintFollowerLastIndex,json=rejectHintFollowerLastIndex,proto3" json:"RejectHintFollowerLastIndex,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptorRaftpb, []int{6} }

func init() {
	proto.RegisterType((*Entry)(nil), "raftpb.Entry")
	proto.RegisterType((*ConfigState)(nil), "raftpb.ConfigState")
	proto.RegisterType((*SnapshotMetadata)(nil), "raftpb.SnapshotMetadata")
	proto.RegisterType((*Snapshot)(nil), "raftpb.Snapshot")
	proto.RegisterType((*HardState)(nil), "raftpb.HardState")
	proto.RegisterType((*ConfigChange)(nil), "raftpb.ConfigChange")
	proto.RegisterType((*Message)(nil), "raftpb.Message")
	proto.RegisterEnum("raftpb.ENTRY_TYPE", ENTRY_TYPE_name, ENTRY_TYPE_value)
	proto.RegisterEnum("raftpb.CONFIG_CHANGE_TYPE", CONFIG_CHANGE_TYPE_name, CONFIG_CHANGE_TYPE_value)
	proto.RegisterEnum("raftpb.MESSAGE_TYPE", MESSAGE_TYPE_name, MESSAGE_TYPE_value)
}
func (m *Entry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Entry) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.Type))
	}
	if m.Index != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.Index))
	}
	if m.Term != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.Term))
	}
	if len(m.Data) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintRaftpb(data, i, uint64(len(m.Data)))
		i += copy(data[i:], m.Data)
	}
	return i, nil
}

func (m *ConfigState) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ConfigState) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IDs) > 0 {
		for _, num := range m.IDs {
			data[i] = 0x8
			i++
			i = encodeVarintRaftpb(data, i, uint64(num))
		}
	}
	return i, nil
}

func (m *SnapshotMetadata) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SnapshotMetadata) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintRaftpb(data, i, uint64(m.ConfigState.Size()))
	n1, err := m.ConfigState.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.Index != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.Index))
	}
	if m.Term != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.Term))
	}
	return i, nil
}

func (m *Snapshot) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Snapshot) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintRaftpb(data, i, uint64(m.Metadata.Size()))
	n2, err := m.Metadata.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	if len(m.Data) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintRaftpb(data, i, uint64(len(m.Data)))
		i += copy(data[i:], m.Data)
	}
	return i, nil
}

func (m *HardState) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HardState) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VotedFor != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.VotedFor))
	}
	if m.CommittedIndex != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.CommittedIndex))
	}
	if m.Term != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.Term))
	}
	return i, nil
}

func (m *ConfigChange) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ConfigChange) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.Type))
	}
	if m.ID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.ID))
	}
	if m.NodeID != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.NodeID))
	}
	if len(m.Data) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintRaftpb(data, i, uint64(len(m.Data)))
		i += copy(data[i:], m.Data)
	}
	return i, nil
}

func (m *Message) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Message) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.Type))
	}
	if m.From != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.From))
	}
	if m.To != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.To))
	}
	if m.CurrentCommittedIndex != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.CurrentCommittedIndex))
	}
	if m.CurrentTerm != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.CurrentTerm))
	}
	if m.LogIndex != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.LogIndex))
	}
	if m.LogTerm != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.LogTerm))
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			data[i] = 0x42
			i++
			i = encodeVarintRaftpb(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	data[i] = 0x4a
	i++
	i = encodeVarintRaftpb(data, i, uint64(m.Snapshot.Size()))
	n3, err := m.Snapshot.MarshalTo(data[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if m.Reject {
		data[i] = 0x50
		i++
		if m.Reject {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.RejectHintFollowerLastIndex != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.RejectHintFollowerLastIndex))
	}
	return i, nil
}

func encodeFixed64Raftpb(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Raftpb(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintRaftpb(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Entry) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovRaftpb(uint64(m.Type))
	}
	if m.Index != 0 {
		n += 1 + sovRaftpb(uint64(m.Index))
	}
	if m.Term != 0 {
		n += 1 + sovRaftpb(uint64(m.Term))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRaftpb(uint64(l))
	}
	return n
}

func (m *ConfigState) Size() (n int) {
	var l int
	_ = l
	if len(m.IDs) > 0 {
		for _, e := range m.IDs {
			n += 1 + sovRaftpb(uint64(e))
		}
	}
	return n
}

func (m *SnapshotMetadata) Size() (n int) {
	var l int
	_ = l
	l = m.ConfigState.Size()
	n += 1 + l + sovRaftpb(uint64(l))
	if m.Index != 0 {
		n += 1 + sovRaftpb(uint64(m.Index))
	}
	if m.Term != 0 {
		n += 1 + sovRaftpb(uint64(m.Term))
	}
	return n
}

func (m *Snapshot) Size() (n int) {
	var l int
	_ = l
	l = m.Metadata.Size()
	n += 1 + l + sovRaftpb(uint64(l))
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRaftpb(uint64(l))
	}
	return n
}

func (m *HardState) Size() (n int) {
	var l int
	_ = l
	if m.VotedFor != 0 {
		n += 1 + sovRaftpb(uint64(m.VotedFor))
	}
	if m.CommittedIndex != 0 {
		n += 1 + sovRaftpb(uint64(m.CommittedIndex))
	}
	if m.Term != 0 {
		n += 1 + sovRaftpb(uint64(m.Term))
	}
	return n
}

func (m *ConfigChange) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovRaftpb(uint64(m.Type))
	}
	if m.ID != 0 {
		n += 1 + sovRaftpb(uint64(m.ID))
	}
	if m.NodeID != 0 {
		n += 1 + sovRaftpb(uint64(m.NodeID))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRaftpb(uint64(l))
	}
	return n
}

func (m *Message) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovRaftpb(uint64(m.Type))
	}
	if m.From != 0 {
		n += 1 + sovRaftpb(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovRaftpb(uint64(m.To))
	}
	if m.CurrentCommittedIndex != 0 {
		n += 1 + sovRaftpb(uint64(m.CurrentCommittedIndex))
	}
	if m.CurrentTerm != 0 {
		n += 1 + sovRaftpb(uint64(m.CurrentTerm))
	}
	if m.LogIndex != 0 {
		n += 1 + sovRaftpb(uint64(m.LogIndex))
	}
	if m.LogTerm != 0 {
		n += 1 + sovRaftpb(uint64(m.LogTerm))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovRaftpb(uint64(l))
		}
	}
	l = m.Snapshot.Size()
	n += 1 + l + sovRaftpb(uint64(l))
	if m.Reject {
		n += 2
	}
	if m.RejectHintFollowerLastIndex != 0 {
		n += 1 + sovRaftpb(uint64(m.RejectHintFollowerLastIndex))
	}
	return n
}

func sovRaftpb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRaftpb(x uint64) (n int) {
	return sovRaftpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Entry) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (ENTRY_TYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Index |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], data[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftpb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigState) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IDs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IDs = append(m.IDs, v)
		default:
			iNdEx = preIndex
			skippy, err := skipRaftpb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotMetadata) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ConfigState.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Index |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaftpb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Snapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Snapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], data[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftpb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HardState) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HardState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HardState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotedFor", wireType)
			}
			m.VotedFor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.VotedFor |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedIndex", wireType)
			}
			m.CommittedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CommittedIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaftpb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigChange) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (CONFIG_CHANGE_TYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NodeID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], data[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftpb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (MESSAGE_TYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.From |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.To |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentCommittedIndex", wireType)
			}
			m.CurrentCommittedIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurrentCommittedIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTerm", wireType)
			}
			m.CurrentTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurrentTerm |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogIndex", wireType)
			}
			m.LogIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LogIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogTerm", wireType)
			}
			m.LogTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LogTerm |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Snapshot.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reject", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reject = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RejectHintFollowerLastIndex", wireType)
			}
			m.RejectHintFollowerLastIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RejectHintFollowerLastIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaftpb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRaftpb(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRaftpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRaftpb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRaftpb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRaftpb(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRaftpb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRaftpb   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorRaftpb = []byte{
	// 916 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x55, 0x5d, 0x73, 0xea, 0x44,
	0x18, 0x26, 0x90, 0x02, 0xe7, 0xa5, 0xa5, 0x71, 0x4f, 0x5b, 0x23, 0x55, 0x0e, 0x72, 0x51, 0x99,
	0x9e, 0x39, 0xed, 0x4c, 0xf5, 0x4a, 0x6f, 0x4c, 0x93, 0xa5, 0x64, 0xcc, 0x07, 0x67, 0xb3, 0x54,
	0x8f, 0x37, 0x99, 0x14, 0xb6, 0x14, 0xa7, 0xb0, 0x4c, 0xd8, 0xaa, 0xf5, 0xca, 0x9f, 0xe1, 0xb5,
	0xbf, 0xa6, 0x97, 0xfe, 0x02, 0x47, 0xeb, 0x1f, 0x71, 0x92, 0x6c, 0xf8, 0xa8, 0x75, 0xf4, 0x06,
	0x78, 0x9f, 0x77, 0x9f, 0x7d, 0x9e, 0xf7, 0x63, 0x07, 0xd0, 0xe3, 0xe8, 0x5a, 0x9c, 0x26, 0x1f,
	0xf3, 0x2b, 0xf9, 0x75, 0x32, 0x8f, 0xb9, 0xe0, 0xa8, 0x9c, 0x45, 0x8d, 0x37, 0xe3, 0x89, 0xb8,
	0xb9, 0xbb, 0x3a, 0x19, 0xf2, 0xe9, 0xe9, 0x98, 0x8f, 0xf9, 0x69, 0x9a, 0xbe, 0xba, 0xbb, 0x4e,
	0xa3, 0x34, 0x48, 0x7f, 0x65, 0xb4, 0xf6, 0x14, 0xb6, 0xf0, 0x4c, 0xc4, 0xf7, 0xe8, 0x08, 0x54,
	0x7a, 0x3f, 0x67, 0xba, 0xd2, 0x52, 0x3a, 0xf5, 0x33, 0x74, 0x22, 0x2f, 0xc7, 0x1e, 0x25, 0xef,
	0x42, 0xfa, 0xae, 0x8f, 0x89, 0x2a, 0xee, 0xe7, 0x0c, 0xed, 0xc1, 0x96, 0x3d, 0x1b, 0xb1, 0x1f,
	0xf5, 0x62, 0x4b, 0xe9, 0xa8, 0x64, 0x6b, 0x92, 0x04, 0x08, 0x81, 0x4a, 0x59, 0x3c, 0xd5, 0x4b,
	0x29, 0xa8, 0x0a, 0x16, 0x4f, 0x13, 0xcc, 0x8a, 0x44, 0xa4, 0xab, 0x2d, 0xa5, 0xb3, 0x4d, 0xd4,
	0x51, 0x24, 0xa2, 0xf6, 0x2b, 0xa8, 0x99, 0x7c, 0x76, 0x3d, 0x19, 0x07, 0x22, 0x12, 0x0c, 0x69,
	0x50, 0xb2, 0xad, 0x85, 0xae, 0xb4, 0x4a, 0x1d, 0x95, 0x94, 0x26, 0xd6, 0xa2, 0x7d, 0x0f, 0x5a,
	0x30, 0x8b, 0xe6, 0x8b, 0x1b, 0x2e, 0x5c, 0x26, 0xa2, 0x84, 0x84, 0xbe, 0xd8, 0x20, 0xa5, 0x0e,
	0x6b, 0x67, 0x2f, 0x73, 0x87, 0x6b, 0xa9, 0x73, 0xf5, 0xe1, 0xf7, 0x57, 0x05, 0x52, 0x1b, 0xae,
	0x49, 0xfc, 0x6f, 0xbf, 0xed, 0x6f, 0xa1, 0x9a, 0x4b, 0xa3, 0xcf, 0xa1, 0x9a, 0xcb, 0x4b, 0x3d,
	0x3d, 0xd7, 0x7b, 0x6a, 0x4f, 0x8a, 0x56, 0xa7, 0xb9, 0xdd, 0xbc, 0xee, 0xe2, 0x5a, 0xdd, 0x43,
	0x78, 0xd1, 0x8b, 0xe2, 0x51, 0x66, 0xa9, 0x01, 0xd5, 0x4b, 0x2e, 0xd8, 0xa8, 0xcb, 0xe3, 0xf4,
	0x72, 0x95, 0x54, 0xbf, 0x97, 0x31, 0x3a, 0x82, 0xba, 0xc9, 0xa7, 0xd3, 0x89, 0x10, 0x6c, 0xb4,
	0xee, 0xbb, 0x3e, 0xdc, 0x40, 0x9f, 0x2d, 0xe0, 0x27, 0xd8, 0xce, 0x9a, 0x61, 0xde, 0x44, 0xb3,
	0x31, 0x43, 0x27, 0x1b, 0x23, 0x6d, 0x2c, 0x1b, 0xe6, 0x7b, 0x5d, 0xfb, 0x22, 0x34, 0x7b, 0x86,
	0x77, 0x81, 0xd7, 0x47, 0x5b, 0x87, 0xa2, 0x6d, 0x49, 0xbd, 0xe2, 0xc4, 0x42, 0x07, 0x50, 0xf6,
	0xf8, 0x88, 0xd9, 0x96, 0x54, 0x29, 0xcf, 0xd2, 0xe8, 0xd9, 0xc1, 0xfe, 0x5a, 0x82, 0x8a, 0xcb,
	0x16, 0x8b, 0x68, 0xcc, 0x50, 0x67, 0x43, 0x77, 0x2f, 0xd7, 0x75, 0x71, 0x10, 0x18, 0x9b, 0x8a,
	0x08, 0xd4, 0x6e, 0xcc, 0xa7, 0x52, 0x53, 0xbd, 0x8e, 0xf9, 0x34, 0x71, 0x41, 0xb9, 0x54, 0x2c,
	0x0a, 0x8e, 0x3e, 0x83, 0x7d, 0xf3, 0x2e, 0x8e, 0xd9, 0x4c, 0x3c, 0x69, 0x8c, 0x9a, 0x1e, 0xd9,
	0x1f, 0x3e, 0x97, 0x44, 0x2d, 0xa8, 0x49, 0x56, 0xda, 0xa6, 0xad, 0xf4, 0x6c, 0x6d, 0xb8, 0x82,
	0x92, 0x29, 0x38, 0x7c, 0x9c, 0x5d, 0x55, 0xce, 0xa6, 0x70, 0x2b, 0x63, 0xa4, 0x43, 0xc5, 0xe1,
	0xe3, 0x94, 0x59, 0x49, 0x53, 0x95, 0xdb, 0x2c, 0x44, 0x6f, 0xa0, 0x92, 0xbc, 0x97, 0x09, 0x5b,
	0xe8, 0xd5, 0x56, 0xa9, 0x53, 0x3b, 0xdb, 0x59, 0xbe, 0x94, 0xe4, 0x19, 0xc9, 0x65, 0xa8, 0xb0,
	0xec, 0x0c, 0x3a, 0x5b, 0xed, 0x94, 0xfe, 0x22, 0xdd, 0x23, 0xed, 0xe9, 0x1e, 0xe5, 0xfb, 0xb3,
	0xc8, 0x77, 0xef, 0x00, 0xca, 0x84, 0x7d, 0xc7, 0x86, 0x42, 0x87, 0x96, 0xd2, 0xa9, 0x92, 0x72,
	0x9c, 0x46, 0xe8, 0x4b, 0x38, 0xcc, 0xf0, 0xde, 0x64, 0x26, 0xba, 0xfc, 0xf6, 0x96, 0xff, 0xc0,
	0x62, 0x27, 0x5a, 0x88, 0xac, 0x86, 0x5a, 0x6a, 0xf4, 0x30, 0xfe, 0xf7, 0x23, 0xc7, 0xaf, 0x01,
	0x56, 0xef, 0x19, 0x01, 0x94, 0x3d, 0x9f, 0xb8, 0x86, 0xa3, 0x15, 0xd0, 0x7b, 0xb0, 0xb3, 0xb1,
	0x16, 0x9a, 0x72, 0x6c, 0x01, 0xfa, 0xe7, 0xa6, 0xa0, 0x6d, 0xa8, 0x1a, 0x96, 0x15, 0x7a, 0xbe,
	0x85, 0xb5, 0x02, 0xda, 0x85, 0x1a, 0xc1, 0xae, 0x7f, 0x89, 0x33, 0x40, 0x49, 0x80, 0x41, 0xdf,
	0x32, 0xa8, 0x04, 0x8a, 0xc7, 0x3f, 0xab, 0xb0, 0xbd, 0x3e, 0x78, 0x74, 0x08, 0xef, 0xdb, 0x1e,
	0xc5, 0xc4, 0x33, 0x9c, 0xd0, 0x34, 0xdc, 0xbe, 0x61, 0x5f, 0x78, 0x61, 0x40, 0x0d, 0x42, 0xb5,
	0x02, 0x6a, 0x43, 0x73, 0x99, 0x74, 0xb0, 0x61, 0x61, 0x12, 0x06, 0xd8, 0xb3, 0xc2, 0x1e, 0x36,
	0x08, 0x3d, 0xc7, 0x06, 0xd5, 0x14, 0xf4, 0x01, 0xec, 0xaf, 0x2e, 0xe8, 0x61, 0xf3, 0xab, 0xf0,
	0xed, 0xc0, 0x27, 0x03, 0x57, 0x2b, 0xa2, 0x0f, 0x41, 0x97, 0xac, 0x25, 0x21, 0x24, 0xf8, 0xed,
	0x00, 0x07, 0x54, 0x2b, 0xa1, 0x03, 0x40, 0xeb, 0x70, 0xd0, 0xf7, 0xbd, 0x00, 0x6b, 0x2a, 0x6a,
	0xc0, 0x81, 0x69, 0x78, 0x96, 0x9d, 0xda, 0xbe, 0xf4, 0x29, 0x5e, 0x72, 0xb6, 0x92, 0xbe, 0x48,
	0x44, 0x1e, 0x2f, 0x27, 0x1d, 0xe8, 0x13, 0xbf, 0xef, 0x07, 0x86, 0xa3, 0x55, 0x12, 0x37, 0x52,
	0xd2, 0xe8, 0xf7, 0x13, 0xab, 0x39, 0xb7, 0x8a, 0x5e, 0xc2, 0xee, 0x12, 0x93, 0xec, 0x17, 0x49,
	0xf9, 0x79, 0x61, 0x9e, 0xd1, 0x0f, 0x7a, 0xfe, 0xca, 0x21, 0xa0, 0x26, 0x34, 0x96, 0xa5, 0xad,
	0xa5, 0x25, 0xb9, 0x86, 0x3e, 0x86, 0x8f, 0x96, 0xf9, 0x81, 0x47, 0xb0, 0x61, 0xf6, 0x8c, 0x73,
	0x07, 0x87, 0x5d, 0xdf, 0x71, 0xfc, 0xaf, 0x31, 0xd1, 0xb6, 0x93, 0x16, 0x3c, 0xed, 0x20, 0x25,
	0x86, 0x17, 0x74, 0x31, 0xd1, 0x76, 0x92, 0x52, 0xbb, 0x3e, 0x31, 0x71, 0x88, 0x1d, 0x6c, 0x52,
	0xdb, 0xf7, 0x42, 0x6a, 0xbb, 0xd8, 0x1f, 0x50, 0xad, 0x8e, 0x8e, 0xe1, 0x48, 0x12, 0xcc, 0x01,
	0x21, 0xd8, 0xa3, 0xa1, 0xe9, 0xbb, 0xae, 0x4d, 0x29, 0xb6, 0x42, 0xdb, 0xb3, 0xf0, 0x37, 0x4b,
	0xa3, 0xbb, 0xe8, 0x35, 0x7c, 0xf2, 0x9f, 0x67, 0xa5, 0x6b, 0xed, 0x7c, 0xef, 0xe1, 0xcf, 0x66,
	0xe1, 0xe1, 0xb1, 0xa9, 0xfc, 0xf6, 0xd8, 0x54, 0xfe, 0x78, 0x6c, 0x2a, 0xbf, 0xfc, 0xd5, 0x2c,
	0x5c, 0x95, 0xd3, 0xff, 0x9f, 0x4f, 0xff, 0x0e, 0x00, 0x00, 0xff, 0xff, 0x7f, 0x06, 0xaa, 0x2e,
	0xd2, 0x06, 0x00, 0x00,
}
