// Code generated by protoc-gen-gogo.
// source: raft/raftpb/raftpb.proto
// DO NOT EDIT!

package raftpb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type ENTRY_TYPE int32

const (
	ENTRY_TYPE_NORMAL        ENTRY_TYPE = 0
	ENTRY_TYPE_CONFIG_CHANGE ENTRY_TYPE = 1
)

var ENTRY_TYPE_name = map[int32]string{
	0: "NORMAL",
	1: "CONFIG_CHANGE",
}
var ENTRY_TYPE_value = map[string]int32{
	"NORMAL":        0,
	"CONFIG_CHANGE": 1,
}

func (x ENTRY_TYPE) String() string {
	return proto.EnumName(ENTRY_TYPE_name, int32(x))
}
func (ENTRY_TYPE) EnumDescriptor() ([]byte, []int) { return fileDescriptorRaftpb, []int{0} }

type CONFIG_CHANGE_TYPE int32

const (
	CONFIG_CHANGE_TYPE_ADD_NODE    CONFIG_CHANGE_TYPE = 0
	CONFIG_CHANGE_TYPE_REMOVE_NODE CONFIG_CHANGE_TYPE = 1
	CONFIG_CHANGE_TYPE_UPDATE_NODE CONFIG_CHANGE_TYPE = 2
)

var CONFIG_CHANGE_TYPE_name = map[int32]string{
	0: "ADD_NODE",
	1: "REMOVE_NODE",
	2: "UPDATE_NODE",
}
var CONFIG_CHANGE_TYPE_value = map[string]int32{
	"ADD_NODE":    0,
	"REMOVE_NODE": 1,
	"UPDATE_NODE": 2,
}

func (x CONFIG_CHANGE_TYPE) String() string {
	return proto.EnumName(CONFIG_CHANGE_TYPE_name, int32(x))
}
func (CONFIG_CHANGE_TYPE) EnumDescriptor() ([]byte, []int) { return fileDescriptorRaftpb, []int{1} }

type MESSAGE_TYPE int32

const (
	// INTERNAL_CAMPAIGN_START message is used locally by Candidate/Follower
	// to start an election after election timeout.
	//
	// Every server in Raft starts as a follower, and when it has not received
	// any message from a valid leader before the randomized election timeout,
	// it will start an election to become a leader. To begin an election, a
	// follower increments its current term and becomes or remains Candidate.
	// Then votes for itself and send RequestVote RPCs in parallel to other peers.
	// (Raft 3.4 Leader election)
	//
	// It is an internal(local) message that is never sent to other peers over the network.
	//
	// (etcd: raft.raftpb.MsgHup)
	MESSAGE_TYPE_INTERNAL_CAMPAIGN_START MESSAGE_TYPE = 0
	// INTERNAL_LEADER_SEND_HEARTBEAT message is used locally by Leader,
	// to signal the leader to send a LEADER_HEARTBEAT_REQUEST to its followers.
	// It is triggered periodically after heartbeat timeouts.
	//
	// It is an internal(local) message that is never sent to other peers over the network.
	//
	// (etcd: raft.raftpb.MsgBeat)
	MESSAGE_TYPE_INTERNAL_LEADER_SEND_HEARTBEAT MESSAGE_TYPE = 1
	// INTERNAL_CHECK_QUORUM message is used locally by Leader,
	// to check if quorum of cluster (including itself) is active.
	// And if not, the leader steps down to a follower.
	//
	// Quorum is cluster size / 2 + 1.
	//
	// It is an internal(local) message that is never sent to other peers over the network.
	//
	// (etcd: raft.raftpb.MsgCheckQuorum)
	MESSAGE_TYPE_INTERNAL_CHECK_QUORUM MESSAGE_TYPE = 2
	// LEADER_HEARTBEAT_REQUEST message is heartbeat from the Leader.
	// It is triggered by INTERNAL_LEADER_SEND_HEARTBEAT message, after every heartbeat
	// timeout, and is sent to leader's followers. It is same as an empty
	// raftpb.MsgApp, but includes raftpb.Message.Commit information for
	// followers.
	//
	//   idx1 = Leader.Follower.Progress.Match
	//   idx2 = Leader.raftLog.CommitIndex
	//   Leader.LEADER_HEARTBEAT_REQUEST.CommitIndex = min(idx1, idx2)
	//
	// So that the followers can update their CommitIndex.
	//
	// (etcd: raft.raftpb.MsgHeartbeat)
	MESSAGE_TYPE_LEADER_HEARTBEAT_REQUEST MESSAGE_TYPE = 3
	// HEARTBEAT_RESPONSE message is the response from Follower,
	// for leader's LEADER_HEARTBEAT_REQUEST. It does not contain any information.
	// When a leader receives this message from a follower, the leader marks
	// this follower as active, and sends raftpb.MsgApp if needed.
	//
	// (etcd: raft.raftpb.MsgHeartbeatResp)
	MESSAGE_TYPE_HEARTBEAT_RESPONSE MESSAGE_TYPE = 4
	// CANDIDATE_VOTE_REQUEST message is sent by Candiate.
	// It is triggered by an election, and sent with the candidate's
	// information:
	//
	//   Candidate.CANDIDATE_VOTE_REQUEST.LogTerm  = Candidate.raftLog.lastTerm()
	//   Candidate.CANDIDATE_VOTE_REQUEST.LogIndex = Candidate.raftLog.lastIndex()
	//
	// (etcd: raft.raftpb.MsgVote)
	MESSAGE_TYPE_CANDIDATE_VOTE_REQUEST MESSAGE_TYPE = 5
	// VOTE_RESPONSE message is the response to CANDIDATE_VOTE_REQUEST.
	//
	//
	// Leader receives CANDIDATE_VOTE_REQUEST from Candidate, and then:
	//
	//   Leader.VOTE_RESPONSE.Reject = true
	//
	//
	// Candidate receives CANDIDATE_VOTE_REQUEST from another candidate, and then:
	//
	//   Candidate.VOTE_RESPONSE.Reject = true
	//
	//
	// Follower receives CANDIDATE_VOTE_REQUEST from Candidate, and IF:
	//
	//   i) Candidate.Message.LogTerm > Follower.raftLog.lastTerm()
	//   OR
	//   ii) Candidate.Message.LogTerm == Follower.raftLog.lastTerm()
	//       AND
	//       Candidate.Message.LogIndex >= Follower.raftLog.lastIndex()
	//
	//   THEN
	//      Follower.VOTE_RESPONSE.To     = Candidate
	//      Follower.VOTE_RESPONSE.Reject = false
	//
	//   ELSE
	//      Follower.VOTE_RESPONSE.To     = Candidate
	//      Follower.VOTE_RESPONSE.Reject = true
	//
	// (etcd: raft.raftpb.MsgVoteResp)
	MESSAGE_TYPE_VOTE_RESPONSE MESSAGE_TYPE = 6
	// PROPOSAL message is used to forward client requests to its
	// leader, because client requests in Raft are processed through the
	// leader. First option is for the server to reject the request and
	// return the endpoint of the leader to the client. Or the server can proxy
	// the client's requests to the leader without rejection, so that clients
	// can talk to any node in the cluster.
	// (Raft 6.2 Routing requests to the leader)
	//
	// For Leader/Candidate, it is an internal(local) message that is never
	// sent to other peers over the network. For Follower, it is forwarded
	// to Leader over the network.
	//
	// It is triggered whenever local node.Propose, only contains:
	//
	//   Leader/Candidate/Follower.PROPOSAL.Entries = Entries
	//
	//
	// Leader receives Leader.PROPOSAL:
	//
	//   Leader.appendEntry(Leader.PROPOSAL.Entries)
	//   Leader.bcastAppend() to followers
	//
	//
	// Candidate receives Candidate.PROPOSAL:
	//
	//   Ignore Candidate.PROPOSAL
	//   because it means that there is no leader
	//
	//
	// Follower receives Follower.PROPOSAL:
	//
	//   i) Ignore Follower.PROPOSAL
	//      if there is no known leader
	//
	//   ii) Send Follower.PROPOSAL to its Leader
	//
	//       Follower.PROPOSAL.To = Leader
	//       Follower.PROPOSAL.Entries = Entries
	//
	//
	// (etcd: raft.raftpb.MsgProp)
	MESSAGE_TYPE_PROPOSAL MESSAGE_TYPE = 7
	// LEADER_APPEND_REQUEST message is only sent by Leader.
	//
	//   newLogIndex   = Leader.Follower.Progress.Next
	//   prevLogIndex  = newLogsIndex - 1
	//   prevLogTerm   = Leader.raftLog.term(prevLogIndex)
	//   entries       = Leader.raftLog.entries(newLogIndex, Leader.maxMsgSize)
	//   leaderCommit  = Leader.raftLog.CommitIndex
	//
	//   Leader.LEADER_APPEND_REQUEST.LogTerm     = prevLogTerm
	//   Leader.LEADER_APPEND_REQUEST.LogIndex    = prevLogIndex
	//   Leader.LEADER_APPEND_REQUEST.Entries     = entries
	//   Leader.LEADER_APPEND_REQUEST.CommitIndex = leaderCommit
	//
	// (etcd: raft.raftpb.MsgApp)
	MESSAGE_TYPE_LEADER_APPEND_REQUEST MESSAGE_TYPE = 8
	// APPEND_RESPONSE message is the response to Leader by Follower.
	//
	//   i) response to LEADER_APPEND_REQUEST:
	//
	//      IF
	//         Follower.raftLog.CommitIndex > Leader.LEADER_APPEND_REQUEST.LogIndex
	//
	//      THEN
	//         Follower.APPEND_RESPONSE.To       = Leader
	//         Follower.APPEND_RESPONSE.LogIndex = Follower.raftLog.CommitIndex
	//         Follower.APPEND_RESPONSE.Reject   = false
	//
	//      AND THEN
	//         Leader updates Leader.Follower.Progress
	//
	//      ELSE IF
	//         Leader.LEADER_APPEND_REQUEST.LogIndex >= Follower.raftLog.CommitIndex
	//
	//      AND IF
	//         term1 = Leader.LEADER_APPEND_REQUEST.LogTerm
	//         term2 = Follower.term(Leader.LEADER_APPEND_REQUEST.LogIndex)
	//         term1 == term2
	//
	//         THEN
	//            idx1 = Leader.LEADER_APPEND_REQUEST.CommitIndex
	//            idx2 = Leader.LEADER_APPEND_REQUEST.LogIndex + len(new entries)
	//            Follower.raftLog.commitTo(min(idx1, idx2))
	//
	//            Follower.APPEND_RESPONSE.To       = Leader
	//            Follower.APPEND_RESPONSE.LogIndex = idx2
	//            Follower.APPEND_RESPONSE.Reject   = false
	//
	//      ELSE //         Follower.APPEND_RESPONSE.To         = Leader
	//         Follower.APPEND_RESPONSE.LogIndex   = Leader.LEADER_APPEND_REQUEST.LogIndex
	//         Follower.APPEND_RESPONSE.Reject     = true
	//         Follower.APPEND_RESPONSE.RejectHint = Follower.raftLog.lastIndex()
	//
	//         THEN
	//            Leader gets this Rejection and updates its Progress with:
	//               idx1 = Follower.APPEND_RESPONSE.LogIndex
	//               idx2 = Follower.APPEND_RESPONSE.RejectHint + 1
	//               Leader.Follower.Progress.Next = min(idx1, idx2)
	//
	//   (etcd: raft.*raft.handleAppendEntries)
	//
	//
	//   ii) response to LEADER_SNAPSHOT_REQUEST
	//
	//      IF
	//         idx1 = Follower.raftLog.CommitIndex
	//         idx2 = Leader.LEADER_SNAPSHOT_REQUEST.Index
	//         idx1 >= idx2
	//            THEN false
	//
	//         term1 = Follower.raftLog.term(Leader.LEADER_SNAPSHOT_REQUEST.Index)
	//         term2 = Leader.LEADER_SNAPSHOT_REQUEST.Term
	//         idx   = Leader.LEADER_SNAPSHOT_REQUEST.Index
	//         term1 == term2
	//            THEN Follower.raftLog.commitTo(idx)
	//            AND THEN false
	//
	//      ELSE
	//         true
	//
	//      IF true, THEN successfully recovered the state machine from a snapshot
	//         Follower.APPEND_RESPONSE.To       = Leader
	//         Follower.APPEND_RESPONSE.LogIndex = Follower.raftLog.lastIndex()
	//         Follower.APPEND_RESPONSE.Reject   = false
	//
	//      ELSE ignores snapshot
	//         Follower.APPEND_RESPONSE.To       = Leader
	//         Follower.APPEND_RESPONSE.LogIndex = Follower.raftLog.CommitIndex
	//         Follower.APPEND_RESPONSE.Reject   = false
	//
	//   (etcd: raft.*raft.handleSnapshot)
	//
	//
	//   iii)
	//      term1 = Follower.Term
	//      term2 = Leader.LEADER_HEARTBEAT_REQUEST.LogTerm
	//      term3 = Leader.LEADER_APPEND_REQUEST.LogTerm
	//      term1 > term2 || term1 > term3
	//
	//         THEN
	//            Follower received message from Leader with a lower term
	//         SO
	//            Follower ignores this message
	//
	//   (etcd: raft.*raft.Step)
	//
	//
	// (etcd: raft.raftpb.MsgAppResp)
	MESSAGE_TYPE_APPEND_RESPONSE MESSAGE_TYPE = 9
	// LEADER_SNAPSHOT_REQUEST is only sent by Leader.
	// It is triggered when the Leader tries to replicate its log (sendAppend) but:
	//
	//   i) term, err = Leader.raftLog.term(Leader.Follower.Progress.Next - 1)
	//      err == ErrCompacted
	//
	//   OR
	//
	//   ii) entries, err = Leader.raftLog.entries(Leader.Follower.Progress.Next, Leader.maxMsgSize)
	//       err != nil
	//
	//   THEN
	//      snap = Leader.raftLog.snapshot()
	//      Leader.LEADER_SNAPSHOT_REQUEST.Snapshot = snap
	//      Leader.Follower.Progress.becomeSnapshot(snap.Index)
	//
	//
	// (etcd: raft.raftpb.MsgSnap)
	MESSAGE_TYPE_LEADER_SNAPSHOT_REQUEST MESSAGE_TYPE = 10
	// SNAPSHOT_RESPONSE message is the response to LEADER_SNAPSHOT_REQUEST from Follower.
	//
	// (etcd: raft.raftpb.MsgSnapStatus)
	MESSAGE_TYPE_SNAPSHOT_RESPONSE MESSAGE_TYPE = 11
	// INTERNAL_UNREACHABLE_FOLLOWER message notifies Leader that Follower is not reachable.
	//
	// It is an internal(local) message that is never sent to other peers over the network.
	//
	// (etcd: raft.raftpb.MsgUnreachable)
	MESSAGE_TYPE_INTERNAL_UNREACHABLE_FOLLOWER MESSAGE_TYPE = 12
)

var MESSAGE_TYPE_name = map[int32]string{
	0:  "INTERNAL_CAMPAIGN_START",
	1:  "INTERNAL_LEADER_SEND_HEARTBEAT",
	2:  "INTERNAL_CHECK_QUORUM",
	3:  "LEADER_HEARTBEAT_REQUEST",
	4:  "HEARTBEAT_RESPONSE",
	5:  "CANDIDATE_VOTE_REQUEST",
	6:  "VOTE_RESPONSE",
	7:  "PROPOSAL",
	8:  "LEADER_APPEND_REQUEST",
	9:  "APPEND_RESPONSE",
	10: "LEADER_SNAPSHOT_REQUEST",
	11: "SNAPSHOT_RESPONSE",
	12: "INTERNAL_UNREACHABLE_FOLLOWER",
}
var MESSAGE_TYPE_value = map[string]int32{
	"INTERNAL_CAMPAIGN_START":        0,
	"INTERNAL_LEADER_SEND_HEARTBEAT": 1,
	"INTERNAL_CHECK_QUORUM":          2,
	"LEADER_HEARTBEAT_REQUEST":       3,
	"HEARTBEAT_RESPONSE":             4,
	"CANDIDATE_VOTE_REQUEST":         5,
	"VOTE_RESPONSE":                  6,
	"PROPOSAL":                       7,
	"LEADER_APPEND_REQUEST":          8,
	"APPEND_RESPONSE":                9,
	"LEADER_SNAPSHOT_REQUEST":        10,
	"SNAPSHOT_RESPONSE":              11,
	"INTERNAL_UNREACHABLE_FOLLOWER":  12,
}

func (x MESSAGE_TYPE) String() string {
	return proto.EnumName(MESSAGE_TYPE_name, int32(x))
}
func (MESSAGE_TYPE) EnumDescriptor() ([]byte, []int) { return fileDescriptorRaftpb, []int{2} }

type Entry struct {
	Type  ENTRY_TYPE `protobuf:"varint,1,opt,name=Type,json=type,proto3,enum=raftpb.ENTRY_TYPE" json:"Type,omitempty"`
	Term  uint64     `protobuf:"varint,2,opt,name=Term,json=term,proto3" json:"Term,omitempty"`
	Index uint64     `protobuf:"varint,3,opt,name=Index,json=index,proto3" json:"Index,omitempty"`
	Data  []byte     `protobuf:"bytes,4,opt,name=Data,json=data,proto3" json:"Data,omitempty"`
}

func (m *Entry) Reset()                    { *m = Entry{} }
func (m *Entry) String() string            { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()               {}
func (*Entry) Descriptor() ([]byte, []int) { return fileDescriptorRaftpb, []int{0} }

type ConfigState struct {
	IDs []uint64 `protobuf:"varint,1,rep,name=IDs,json=iDs" json:"IDs,omitempty"`
}

func (m *ConfigState) Reset()                    { *m = ConfigState{} }
func (m *ConfigState) String() string            { return proto.CompactTextString(m) }
func (*ConfigState) ProtoMessage()               {}
func (*ConfigState) Descriptor() ([]byte, []int) { return fileDescriptorRaftpb, []int{1} }

type SnapshotMetadata struct {
	ConfigState *ConfigState `protobuf:"bytes,1,opt,name=ConfigState,json=configState" json:"ConfigState,omitempty"`
	Term        uint64       `protobuf:"varint,2,opt,name=Term,json=term,proto3" json:"Term,omitempty"`
	Index       uint64       `protobuf:"varint,3,opt,name=Index,json=index,proto3" json:"Index,omitempty"`
}

func (m *SnapshotMetadata) Reset()                    { *m = SnapshotMetadata{} }
func (m *SnapshotMetadata) String() string            { return proto.CompactTextString(m) }
func (*SnapshotMetadata) ProtoMessage()               {}
func (*SnapshotMetadata) Descriptor() ([]byte, []int) { return fileDescriptorRaftpb, []int{2} }

// Snapshot contains snapshot data and meta-data.
// It is stored in stable storage before messages are sent.
type Snapshot struct {
	Metadata *SnapshotMetadata `protobuf:"bytes,1,opt,name=Metadata,json=metadata" json:"Metadata,omitempty"`
	Data     []byte            `protobuf:"bytes,2,opt,name=Data,json=data,proto3" json:"Data,omitempty"`
}

func (m *Snapshot) Reset()                    { *m = Snapshot{} }
func (m *Snapshot) String() string            { return proto.CompactTextString(m) }
func (*Snapshot) ProtoMessage()               {}
func (*Snapshot) Descriptor() ([]byte, []int) { return fileDescriptorRaftpb, []int{3} }

// HardState is the current state of the Raft node.
// It is stored in stable storage before messages are sent.
type HardState struct {
	VotedFor    uint64 `protobuf:"varint,1,opt,name=VotedFor,json=votedFor,proto3" json:"VotedFor,omitempty"`
	Term        uint64 `protobuf:"varint,2,opt,name=Term,json=term,proto3" json:"Term,omitempty"`
	CommitIndex uint64 `protobuf:"varint,3,opt,name=CommitIndex,json=commitIndex,proto3" json:"CommitIndex,omitempty"`
}

func (m *HardState) Reset()                    { *m = HardState{} }
func (m *HardState) String() string            { return proto.CompactTextString(m) }
func (*HardState) ProtoMessage()               {}
func (*HardState) Descriptor() ([]byte, []int) { return fileDescriptorRaftpb, []int{4} }

type ConfigChange struct {
	Type   CONFIG_CHANGE_TYPE `protobuf:"varint,1,opt,name=Type,json=type,proto3,enum=raftpb.CONFIG_CHANGE_TYPE" json:"Type,omitempty"`
	ID     uint64             `protobuf:"varint,2,opt,name=ID,json=iD,proto3" json:"ID,omitempty"`
	NodeID uint64             `protobuf:"varint,3,opt,name=NodeID,json=nodeID,proto3" json:"NodeID,omitempty"`
	Data   []byte             `protobuf:"bytes,4,opt,name=Data,json=data,proto3" json:"Data,omitempty"`
}

func (m *ConfigChange) Reset()                    { *m = ConfigChange{} }
func (m *ConfigChange) String() string            { return proto.CompactTextString(m) }
func (*ConfigChange) ProtoMessage()               {}
func (*ConfigChange) Descriptor() ([]byte, []int) { return fileDescriptorRaftpb, []int{5} }

// Message contains messages between nodes.
type Message struct {
	// Type defines the type of Message.
	Type MESSAGE_TYPE `protobuf:"varint,1,opt,name=Type,json=type,proto3,enum=raftpb.MESSAGE_TYPE" json:"Type,omitempty"`
	// From is the ID of the sender node.
	// (etcd: raft.raftpb.Message.From)
	From uint64 `protobuf:"varint,2,opt,name=From,json=from,proto3" json:"From,omitempty"`
	// To is the ID of the receiver node.
	// (etcd: raft.raftpb.Message.To)
	To uint64 `protobuf:"varint,3,opt,name=To,json=to,proto3" json:"To,omitempty"`
	// CurrentTerm is the latest term that server has seen,
	// initialized to 0 on first boot, increasing monotonically.
	// CurrentTerm is 0 for local messages.
	//
	// CurrentTerm gets updated whenever node sends out messages.
	//
	// If a node receives a message with higher CurrentTerm,
	// it reverts back to Follower.
	// (etcd: raft.Step)
	//
	// If a node receives a message with lower CurrentTerm,
	// it ignores that message.
	// (etcd: raft.Step)
	//
	// Candidate starts an election by increasing CurrentTerm by 1.
	//
	// Follower overwrites its CurrentTerm with leader's CurrentTerm.
	//
	// (etcd: raft.raftpb.Message.Term)
	CurrentTerm uint64 `protobuf:"varint,4,opt,name=CurrentTerm,json=currentTerm,proto3" json:"CurrentTerm,omitempty"`
	// LogTerm is the term of LogIndex, where new log entries start.
	//
	//
	// Leader updates Message.LogTerm when sending out:
	//
	//   AppendEntries with:
	//
	//      Leader.Message.LogTerm  = Leader.raftLog.term(Leader.Follower.Progress.Next - 1)
	//      Leader.Message.LogIndex = Leader.Follower.Progress.Next - 1
	//
	//   to tell followers where new log entries start.
	//   New log entries start from Leader.Follower.Progress.Next.
	//   (etcd: raft.*raft.sendAppend with raftpb.MsgApp)
	//
	//
	// Candidate updates Message.LogTerm when sending out:
	//
	//   RequestVote with:
	//
	//      Leader.Message.LogTerm  = Follower.raftLog.lastTerm().
	//      Leader.Message.LogIndex = Follower.raftLog.lastIndex().
	//
	//   (etcd: raft.*raft.campaign with raftpb.MsgVote)
	//
	//
	// Follower receives/reads Leader.Message.LogTerm:
	//
	//   1. When receiving RequestVote from Leader:
	//
	//   Follower only accepts the message when Leader's log is more up-to-date.
	//
	//      i)  Leader.Message.LogTerm > Follower.raftLog.lastTerm()
	//
	//      OR
	//
	//      ii) Leader.Message.LogTerm == Follower.raftLog.lastTerm()
	//          AND
	//          Leader.Message.LogIndex >= Follower.raftLog.lastIndex()
	//
	//   (etcd: raft.*raftLog.isUpToDate with raftpb.MsgVoteResp)
	//
	//
	//   2. When Follower receives AppendEntries from Leader:
	//   AppendEntries is only successful when:
	//
	//      i)  Follower.raftLog.CommitIndex > Leader.Message.LogIndex
	//
	//      to tell Follower is ahead of that message, so Follower ignores
	//      this Message, and Leader can update Leader.Follower.Progress.Next.
	//
	//      It will respond with:
	//         - To: Leader
	//         - Type: raftpb.MsgAppResp
	//         - LogIndex: Follower.raftLog.CommitIndex
	//
	//      (etcd: raft.*raft.handleAppendEntries, raft.*Progress.maybeUpdate)
	//
	//      OR
	//
	//      ii) Follower.term(Leader.LogIndex) == Leader.Message.LogTerm
	//
	//      Otherwise, rejects AppendEntries RPC and responds to leader with:
	//         - To: Leader
	//         - Type: raftpb.MsgAppResp
	//         - LogIndex: Leader.Message.LogIndex
	//         - Reject: true
	//         - RejectHint: Follower.raftLog.lastIndex()
	//
	//      Conflicts:
	//
	//         Follower.term(Leader.Message.Entries[i].Index)
	//            != Leader.Message.Entries[i].Term
	//
	//      Then overwrite with Leader's log.
	//
	//      idx1 = Leader.Message.CommitIndex
	//      idx2 = Leader.Message.LogIndex + len(Leader.Message.Entries)
	//      Follower.raftLog.commitTo(min(idx1, idx2))
	//
	//      (etcd: raft.*raft.handleAppendEntries, maybeAppend)
	//
	//
	// (etcd: raft.raftpb.Message.LogTerm)
	LogTerm uint64 `protobuf:"varint,5,opt,name=LogTerm,json=logTerm,proto3" json:"LogTerm,omitempty"`
	// LogIndex is the index of log entry immediately preceding the new ones.
	//
	//
	// Leader updates Leader.LogIndex when sending out:
	//
	//   i) RequestVote with:
	//
	//      Leader.Message.LogTerm  = Leader.raftLog.lastTerm()
	//      Leader.Message.LogIndex = Leader.raftLog.lastIndex()
	//
	//   so that Follower can reject or not.
	//   (etcd: raft.*raft.campaign with raftpb.MsgVote)
	//
	//   OR
	//
	//   ii) AppendEntries with:
	//
	//      Leader.Message.LogTerm  = Leader.raftLog.term(Leader.Follower.Progress.Next - 1)
	//      Leader.Message.LogIndex = Leader.Follower.Progress.Next - 1
	//
	//   to tell its Follower where those new entries start.
	//   (etcd: raft.*raft.sendAppend with raftpb.MsgApp)
	//
	//
	// Follower rejects RequestVote when:
	//
	//   i) Follower.raftLog.lastTerm() > Leader.Message.LogTerm
	//   (etcd: raft.stepFollower with raftpb.MsgVoteResp)
	//
	//   AND
	//
	//   ii) Follower.raftLog.lastIndex() > Leader.Message.LogIndex
	//   (etcd: raft.stepFollower with raftpb.MsgVoteResp)
	//
	//
	// Follower rejects AppendEntries when:
	//
	//   Follower.term(Leader.LogIndex) != Leader.Message.LogTerm
	//
	// (etcd: raft.*raft.handleAppendEntries, maybeAppend)
	//
	//
	// (etcd: raft.raftpb.Message.Index)
	LogIndex uint64 `protobuf:"varint,6,opt,name=LogIndex,json=logIndex,proto3" json:"LogIndex,omitempty"`
	// CommitIndex is the index of highest log entry that is known to be
	// committed (initialized to 0, increasing monotonically). It is the
	// highest log position that is known to be in stable storage on a
	// quorum of nodes in the cluster.
	//
	//
	// Leader updates CommitIndex when sending out AppendEntries:
	//
	//   Leader.Message.CommitIndex = Leader.raftLog.committed
	//
	// (etcd: raft.*raft.sendAppend with raftpb.MsgApp)
	//
	//
	// Follower receives/reads Leader.CommitIndex in AppendEntries
	// and AppendEntries is only successful when:
	//
	//   i) Follower.raftLog.CommitIndex > Leader.Message.LogIndex
	//   (etcd: raft.*raft.handleAppendEntries, raft.*Progress.maybeUpdate)
	//
	//   OR
	//
	//   ii) Follower.term(Leader.LogIndex) == Leader.Message.LogTerm
	//
	//   Conflicts:
	//
	//      Follower.term(Leader.Message.Entries[i].Index)
	//         != Leader.Message.Entries[i].Term
	//
	//   Then overwrite with Leader's log.
	//
	//   idx1 = Leader.Message.CommitIndex
	//   idx2 = Leader.Message.LogIndex + len(Leader.Message.Entries)
	//   Follower.raftLog.commitTo(min(idx1, idx2))
	//
	//   (etcd: raft.*raftLog.maybeAppend)
	//
	//
	// (etcd: raft.raftpb.Message.Commit)
	CommitIndex uint64 `protobuf:"varint,7,opt,name=CommitIndex,json=commitIndex,proto3" json:"CommitIndex,omitempty"`
	// Entries is an array of Entry. They are stored in stable storage
	// before messages are sent.
	//
	// (etcd: raft.raftpb.Message.Entries)
	Entries []*Entry `protobuf:"bytes,8,rep,name=Entries,json=entries" json:"Entries,omitempty"`
	// Snapshot represents current in-memory state of the server.
	// It is stored in stable storage before messages are sent.
	//
	// To prevent logs from growing unbounded, Raft servers compact their
	// logs when the quorum of cluster is available. But when the unavailable
	// minority of servers become available, they need to catch up, by
	// receiving the snapshots from leader, because those missing log entries
	// are possibly gone forever (compacted). So servers sometimes sends snapshots
	// to each other across the network. Write-ahead log approach continuously
	// snapshots to the disk.
	//
	// When the leader decides to snapshot, it first logs a special start
	// entry. For slow followers, the leader will have to send an AppendEntries
	// RPC to the follower with an entry that the leader has already discarded
	// (compacted). In this case, the follower should just discard its entire
	// state. The leader will send the follower the log entries beginning with
	// the start entry.
	//
	// (etcd: raft.raftpb.Message.Snapshot)
	Snapshot *Snapshot `protobuf:"bytes,9,opt,name=Snapshot,json=snapshot" json:"Snapshot,omitempty"`
	// Reject is true when rejecting Message.
	// (etcd: raft.raftpb.Message.Reject, raftpb.MsgVoteResp)
	Reject bool `protobuf:"varint,10,opt,name=Reject,json=reject,proto3" json:"Reject,omitempty"`
	// RejectHint is used to tell Leader the correct index.
	//
	// Follower sets:
	//
	//   Follower.Message.Type = raftpb.MsgAppResp
	//   Follower.Message.LogIndex = Leader.Message.LogIndex
	//   Follower.Message.Reject = true
	//   Follower.Message.RejectHint = Follower.raftLog.lastIndex()
	//
	//   (etcd: raft.*raft.handleAppendEntries)
	//
	// Then Leader receives this Mesasge with Message.Reject,
	// and decreases(updates):
	//
	//   idx1 = Follower.Message.LogIndex
	//   idx2 = Follower.Message.RejectHint
	//   Leader.Follower.Progress.Next = min(idx1, idx2)
	//
	//   (etcd: raft.stepLeader with raftpb.MsgAppResp)
	//
	//
	// (etcd: raft.raftpb.Message.RejectHint, raftpb.MsgAppResp)
	RejectHint uint64 `protobuf:"varint,11,opt,name=RejectHint,json=rejectHint,proto3" json:"RejectHint,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptorRaftpb, []int{6} }

func init() {
	proto.RegisterType((*Entry)(nil), "raftpb.Entry")
	proto.RegisterType((*ConfigState)(nil), "raftpb.ConfigState")
	proto.RegisterType((*SnapshotMetadata)(nil), "raftpb.SnapshotMetadata")
	proto.RegisterType((*Snapshot)(nil), "raftpb.Snapshot")
	proto.RegisterType((*HardState)(nil), "raftpb.HardState")
	proto.RegisterType((*ConfigChange)(nil), "raftpb.ConfigChange")
	proto.RegisterType((*Message)(nil), "raftpb.Message")
	proto.RegisterEnum("raftpb.ENTRY_TYPE", ENTRY_TYPE_name, ENTRY_TYPE_value)
	proto.RegisterEnum("raftpb.CONFIG_CHANGE_TYPE", CONFIG_CHANGE_TYPE_name, CONFIG_CHANGE_TYPE_value)
	proto.RegisterEnum("raftpb.MESSAGE_TYPE", MESSAGE_TYPE_name, MESSAGE_TYPE_value)
}
func (m *Entry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Entry) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.Type))
	}
	if m.Term != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.Term))
	}
	if m.Index != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.Index))
	}
	if len(m.Data) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintRaftpb(data, i, uint64(len(m.Data)))
		i += copy(data[i:], m.Data)
	}
	return i, nil
}

func (m *ConfigState) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ConfigState) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IDs) > 0 {
		for _, num := range m.IDs {
			data[i] = 0x8
			i++
			i = encodeVarintRaftpb(data, i, uint64(num))
		}
	}
	return i, nil
}

func (m *SnapshotMetadata) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SnapshotMetadata) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConfigState != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.ConfigState.Size()))
		n1, err := m.ConfigState.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.Term != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.Term))
	}
	if m.Index != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.Index))
	}
	return i, nil
}

func (m *Snapshot) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Snapshot) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		data[i] = 0xa
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.Metadata.Size()))
		n2, err := m.Metadata.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Data) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintRaftpb(data, i, uint64(len(m.Data)))
		i += copy(data[i:], m.Data)
	}
	return i, nil
}

func (m *HardState) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *HardState) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VotedFor != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.VotedFor))
	}
	if m.Term != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.Term))
	}
	if m.CommitIndex != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.CommitIndex))
	}
	return i, nil
}

func (m *ConfigChange) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ConfigChange) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.Type))
	}
	if m.ID != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.ID))
	}
	if m.NodeID != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.NodeID))
	}
	if len(m.Data) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintRaftpb(data, i, uint64(len(m.Data)))
		i += copy(data[i:], m.Data)
	}
	return i, nil
}

func (m *Message) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Message) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.Type))
	}
	if m.From != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.From))
	}
	if m.To != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.To))
	}
	if m.CurrentTerm != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.CurrentTerm))
	}
	if m.LogTerm != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.LogTerm))
	}
	if m.LogIndex != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.LogIndex))
	}
	if m.CommitIndex != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.CommitIndex))
	}
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			data[i] = 0x42
			i++
			i = encodeVarintRaftpb(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Snapshot != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.Snapshot.Size()))
		n3, err := m.Snapshot.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Reject {
		data[i] = 0x50
		i++
		if m.Reject {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.RejectHint != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintRaftpb(data, i, uint64(m.RejectHint))
	}
	return i, nil
}

func encodeFixed64Raftpb(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Raftpb(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintRaftpb(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Entry) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovRaftpb(uint64(m.Type))
	}
	if m.Term != 0 {
		n += 1 + sovRaftpb(uint64(m.Term))
	}
	if m.Index != 0 {
		n += 1 + sovRaftpb(uint64(m.Index))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRaftpb(uint64(l))
	}
	return n
}

func (m *ConfigState) Size() (n int) {
	var l int
	_ = l
	if len(m.IDs) > 0 {
		for _, e := range m.IDs {
			n += 1 + sovRaftpb(uint64(e))
		}
	}
	return n
}

func (m *SnapshotMetadata) Size() (n int) {
	var l int
	_ = l
	if m.ConfigState != nil {
		l = m.ConfigState.Size()
		n += 1 + l + sovRaftpb(uint64(l))
	}
	if m.Term != 0 {
		n += 1 + sovRaftpb(uint64(m.Term))
	}
	if m.Index != 0 {
		n += 1 + sovRaftpb(uint64(m.Index))
	}
	return n
}

func (m *Snapshot) Size() (n int) {
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovRaftpb(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRaftpb(uint64(l))
	}
	return n
}

func (m *HardState) Size() (n int) {
	var l int
	_ = l
	if m.VotedFor != 0 {
		n += 1 + sovRaftpb(uint64(m.VotedFor))
	}
	if m.Term != 0 {
		n += 1 + sovRaftpb(uint64(m.Term))
	}
	if m.CommitIndex != 0 {
		n += 1 + sovRaftpb(uint64(m.CommitIndex))
	}
	return n
}

func (m *ConfigChange) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovRaftpb(uint64(m.Type))
	}
	if m.ID != 0 {
		n += 1 + sovRaftpb(uint64(m.ID))
	}
	if m.NodeID != 0 {
		n += 1 + sovRaftpb(uint64(m.NodeID))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRaftpb(uint64(l))
	}
	return n
}

func (m *Message) Size() (n int) {
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovRaftpb(uint64(m.Type))
	}
	if m.From != 0 {
		n += 1 + sovRaftpb(uint64(m.From))
	}
	if m.To != 0 {
		n += 1 + sovRaftpb(uint64(m.To))
	}
	if m.CurrentTerm != 0 {
		n += 1 + sovRaftpb(uint64(m.CurrentTerm))
	}
	if m.LogTerm != 0 {
		n += 1 + sovRaftpb(uint64(m.LogTerm))
	}
	if m.LogIndex != 0 {
		n += 1 + sovRaftpb(uint64(m.LogIndex))
	}
	if m.CommitIndex != 0 {
		n += 1 + sovRaftpb(uint64(m.CommitIndex))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovRaftpb(uint64(l))
		}
	}
	if m.Snapshot != nil {
		l = m.Snapshot.Size()
		n += 1 + l + sovRaftpb(uint64(l))
	}
	if m.Reject {
		n += 2
	}
	if m.RejectHint != 0 {
		n += 1 + sovRaftpb(uint64(m.RejectHint))
	}
	return n
}

func sovRaftpb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRaftpb(x uint64) (n int) {
	return sovRaftpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Entry) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (ENTRY_TYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Index |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], data[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftpb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigState) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IDs", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IDs = append(m.IDs, v)
		default:
			iNdEx = preIndex
			skippy, err := skipRaftpb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotMetadata) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigState == nil {
				m.ConfigState = &ConfigState{}
			}
			if err := m.ConfigState.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Index |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaftpb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Snapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Snapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &SnapshotMetadata{}
			}
			if err := m.Metadata.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], data[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftpb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HardState) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HardState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HardState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VotedFor", wireType)
			}
			m.VotedFor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.VotedFor |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Term |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitIndex", wireType)
			}
			m.CommitIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CommitIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaftpb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigChange) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (CONFIG_CHANGE_TYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.NodeID |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftpb
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], data[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftpb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Type |= (MESSAGE_TYPE(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.From |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.To |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTerm", wireType)
			}
			m.CurrentTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CurrentTerm |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogTerm", wireType)
			}
			m.LogTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LogTerm |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogIndex", wireType)
			}
			m.LogIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LogIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitIndex", wireType)
			}
			m.CommitIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CommitIndex |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftpb
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Snapshot == nil {
				m.Snapshot = &Snapshot{}
			}
			if err := m.Snapshot.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reject", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reject = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RejectHint", wireType)
			}
			m.RejectHint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.RejectHint |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaftpb(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaftpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRaftpb(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRaftpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaftpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRaftpb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRaftpb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRaftpb(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRaftpb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRaftpb   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorRaftpb = []byte{
	// 807 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x54, 0xdd, 0x72, 0xda, 0x46,
	0x14, 0x46, 0x42, 0x08, 0xf9, 0x40, 0x12, 0xe5, 0xc4, 0x71, 0x55, 0xb7, 0xa5, 0x94, 0x8b, 0x96,
	0x71, 0x5b, 0x7b, 0xc6, 0x6d, 0x1f, 0x60, 0x8d, 0xd6, 0x86, 0xa9, 0x90, 0x94, 0x95, 0x70, 0x27,
	0x17, 0x1d, 0x8d, 0x6c, 0xd6, 0x98, 0x4e, 0x40, 0x8c, 0x58, 0x77, 0xea, 0x3e, 0x49, 0x1f, 0x29,
	0x97, 0x7d, 0x84, 0xd4, 0xed, 0x83, 0x74, 0xb4, 0xfa, 0x01, 0x9c, 0x5c, 0xe4, 0x06, 0x38, 0xdf,
	0xd9, 0xb3, 0xdf, 0xf7, 0x9d, 0xb3, 0x07, 0xb0, 0xd2, 0xf8, 0x46, 0x9c, 0x64, 0x1f, 0xab, 0xab,
	0xe2, 0xeb, 0x78, 0x95, 0x26, 0x22, 0x41, 0x3d, 0x8f, 0x0e, 0xbf, 0x9f, 0xcd, 0xc5, 0xed, 0xdd,
	0xd5, 0xf1, 0x75, 0xb2, 0x38, 0x99, 0x25, 0xb3, 0xe4, 0x44, 0xa6, 0xaf, 0xee, 0x6e, 0x64, 0x24,
	0x03, 0xf9, 0x2b, 0x2f, 0xeb, 0x2d, 0xa0, 0x41, 0x97, 0x22, 0xbd, 0xc7, 0xaf, 0x41, 0x0b, 0xef,
	0x57, 0xdc, 0x52, 0xba, 0x4a, 0xff, 0xe9, 0x29, 0x1e, 0x17, 0x97, 0x53, 0x37, 0x64, 0xaf, 0xa3,
	0xf0, 0xb5, 0x4f, 0x99, 0x26, 0xee, 0x57, 0x1c, 0x11, 0xb4, 0x90, 0xa7, 0x0b, 0x4b, 0xed, 0x2a,
	0x7d, 0x8d, 0x69, 0x82, 0xa7, 0x0b, 0xdc, 0x87, 0xc6, 0x68, 0x39, 0xe5, 0x7f, 0x58, 0x75, 0x09,
	0x36, 0xe6, 0x59, 0x90, 0x9d, 0xb4, 0x63, 0x11, 0x5b, 0x5a, 0x57, 0xe9, 0xb7, 0x99, 0x36, 0x8d,
	0x45, 0xdc, 0xfb, 0x12, 0x5a, 0x83, 0x64, 0x79, 0x33, 0x9f, 0x05, 0x22, 0x16, 0x1c, 0x4d, 0xa8,
	0x8f, 0xec, 0xb5, 0xa5, 0x74, 0xeb, 0x7d, 0x8d, 0xd5, 0xe7, 0xf6, 0xba, 0xb7, 0x06, 0x33, 0x58,
	0xc6, 0xab, 0xf5, 0x6d, 0x22, 0xc6, 0x5c, 0xc4, 0x59, 0x11, 0xfe, 0xb4, 0x53, 0x24, 0x15, 0xb6,
	0x4e, 0x5f, 0x94, 0x0a, 0xb7, 0x52, 0xac, 0x75, 0xbd, 0x75, 0xf9, 0x47, 0x2b, 0xed, 0x85, 0x60,
	0x94, 0xa4, 0xf8, 0x23, 0x18, 0x25, 0x71, 0xc1, 0x64, 0x95, 0x4c, 0x8f, 0x85, 0x31, 0x63, 0x51,
	0x4a, 0x2c, 0xbd, 0xaa, 0x5b, 0x5e, 0x7f, 0x85, 0xbd, 0x61, 0x9c, 0x4e, 0x73, 0x31, 0x87, 0x60,
	0x5c, 0x26, 0x82, 0x4f, 0xcf, 0x93, 0x54, 0x5e, 0xab, 0x31, 0xe3, 0xf7, 0x22, 0xfe, 0xa0, 0xd0,
	0x6e, 0xe6, 0x79, 0xb1, 0x98, 0x8b, 0x6d, 0xb9, 0xad, 0xeb, 0x0d, 0xd4, 0xfb, 0x13, 0xda, 0xb9,
	0xf5, 0xc1, 0x6d, 0xbc, 0x9c, 0x71, 0x3c, 0xde, 0x19, 0xe0, 0x61, 0xd5, 0x1e, 0xcf, 0x3d, 0x1f,
	0x5d, 0x44, 0x83, 0x21, 0x71, 0x2f, 0xe8, 0xf6, 0x20, 0x9f, 0x82, 0x3a, 0xb2, 0x0b, 0x4e, 0x75,
	0x6e, 0xe3, 0x01, 0xe8, 0x6e, 0x32, 0xe5, 0x23, 0xbb, 0x20, 0xd3, 0x97, 0x32, 0xfa, 0xe0, 0x18,
	0xdf, 0xa9, 0xd0, 0x1c, 0xf3, 0xf5, 0x3a, 0x9e, 0x71, 0xec, 0xef, 0xf0, 0xee, 0x97, 0xbc, 0x63,
	0x1a, 0x04, 0x64, 0x97, 0x11, 0x41, 0x3b, 0x4f, 0x93, 0xca, 0xe7, 0x4d, 0x9a, 0x2c, 0x32, 0x15,
	0x61, 0x52, 0x30, 0xaa, 0x22, 0x91, 0xbe, 0xef, 0xd2, 0x94, 0x2f, 0x85, 0x6c, 0x89, 0x56, 0xf8,
	0xde, 0x40, 0x68, 0x41, 0xd3, 0x49, 0x66, 0x32, 0xdb, 0x90, 0xd9, 0xe6, 0x9b, 0x3c, 0xcc, 0x7a,
	0xec, 0x24, 0xb3, 0xbc, 0x61, 0x7a, 0xde, 0xe3, 0x37, 0x45, 0xfc, 0xb8, 0x9f, 0xcd, 0xf7, 0xfa,
	0x89, 0xdf, 0x40, 0x33, 0xdb, 0x84, 0x39, 0x5f, 0x5b, 0x46, 0xb7, 0xde, 0x6f, 0x9d, 0x3e, 0xa9,
	0x76, 0x20, 0x5b, 0x10, 0xd6, 0xe4, 0x79, 0x16, 0xbf, 0xdb, 0xbc, 0x16, 0x6b, 0x4f, 0xbe, 0x10,
	0xf3, 0xf1, 0x0b, 0x61, 0xc6, 0xba, 0x7c, 0x4f, 0x07, 0xa0, 0x33, 0xfe, 0x1b, 0xbf, 0x16, 0x16,
	0x74, 0x95, 0xbe, 0xc1, 0xf4, 0x54, 0x46, 0xd8, 0x01, 0xc8, 0xf1, 0xe1, 0x7c, 0x29, 0xac, 0x96,
	0xd4, 0x03, 0x69, 0x85, 0x1c, 0x7d, 0x0b, 0xb0, 0xd9, 0x3d, 0x04, 0xd0, 0x5d, 0x8f, 0x8d, 0x89,
	0x63, 0xd6, 0xf0, 0x39, 0x3c, 0xd9, 0x19, 0xaa, 0xa9, 0x1c, 0xd9, 0x80, 0xef, 0xcf, 0x19, 0xdb,
	0x60, 0x10, 0xdb, 0x8e, 0x5c, 0xcf, 0xa6, 0x66, 0x0d, 0x9f, 0x41, 0x8b, 0xd1, 0xb1, 0x77, 0x49,
	0x73, 0x40, 0xc9, 0x80, 0x89, 0x6f, 0x93, 0xb0, 0x00, 0xd4, 0xa3, 0xff, 0x54, 0x68, 0x6f, 0x8f,
	0x0d, 0x3f, 0x83, 0x4f, 0x46, 0x6e, 0x48, 0x99, 0x4b, 0x9c, 0x68, 0x40, 0xc6, 0x3e, 0x19, 0x5d,
	0xb8, 0x51, 0x10, 0x12, 0x16, 0x9a, 0x35, 0xec, 0x41, 0xa7, 0x4a, 0x3a, 0x94, 0xd8, 0x94, 0x45,
	0x01, 0x75, 0xed, 0x68, 0x48, 0x09, 0x0b, 0xcf, 0x28, 0x09, 0x4d, 0x05, 0x3f, 0x85, 0x97, 0x9b,
	0x0b, 0x86, 0x74, 0xf0, 0x73, 0xf4, 0x6a, 0xe2, 0xb1, 0xc9, 0xd8, 0x54, 0xf1, 0x73, 0xb0, 0x8a,
	0xaa, 0xaa, 0x20, 0x62, 0xf4, 0xd5, 0x84, 0x06, 0xa1, 0x59, 0xc7, 0x03, 0xc0, 0x6d, 0x38, 0xf0,
	0x3d, 0x37, 0xa0, 0xa6, 0x86, 0x87, 0x70, 0x30, 0x20, 0xae, 0x3d, 0x92, 0xb2, 0x2f, 0xbd, 0x90,
	0x56, 0x35, 0x8d, 0xac, 0x2f, 0x05, 0x52, 0x1c, 0xd7, 0xb3, 0x0e, 0xf8, 0xcc, 0xf3, 0xbd, 0x80,
	0x38, 0x66, 0x33, 0x53, 0x53, 0x50, 0x12, 0xdf, 0xcf, 0xa4, 0x96, 0xb5, 0x06, 0xbe, 0x80, 0x67,
	0x15, 0x56, 0x54, 0xef, 0x65, 0xf6, 0x4b, 0x63, 0x2e, 0xf1, 0x83, 0xa1, 0xb7, 0x51, 0x08, 0xf8,
	0x12, 0x9e, 0x6f, 0xa1, 0x45, 0x4d, 0x0b, 0xbf, 0x82, 0x2f, 0x2a, 0xc7, 0x13, 0x97, 0x51, 0x32,
	0x18, 0x92, 0x33, 0x87, 0x46, 0xe7, 0x9e, 0xe3, 0x78, 0xbf, 0x50, 0x66, 0xb6, 0xcf, 0xf6, 0xdf,
	0xfe, 0xd3, 0xa9, 0xbd, 0x7d, 0xe8, 0x28, 0x7f, 0x3f, 0x74, 0x94, 0x77, 0x0f, 0x1d, 0xe5, 0xaf,
	0x7f, 0x3b, 0xb5, 0x2b, 0x5d, 0xfe, 0x1f, 0xff, 0xf0, 0x7f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xe7,
	0x16, 0x70, 0x17, 0xe2, 0x05, 0x00, 0x00,
}
